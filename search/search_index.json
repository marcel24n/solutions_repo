{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 \ud83d\udcd8 1. Theoretical Foundation We start with the equations of projectile motion , assuming: - No air resistance - Launched from ground level - Constant gravitational acceleration g = 9.81 m/s\u00b2 \u25b6\ufe0f Basic Kinematic Equations: Let a projectile be launched with: - Initial velocity: \\( v_0 \\) - Angle of projection: \\( \\theta \\) - From: \\( y_0 = 0 \\) Split into horizontal and vertical components: - \\( v_{x} = v_0 \\cos\\theta \\) - \\( v_{y} = v_0 \\sin\\theta \\) Time of flight (when projectile returns to ground): \\[ t_{\\text{flight}} = \\frac{2v_0 \\sin\\theta}{g} \\] Horizontal Range: \\[ R = v_{x} \\cdot t_{\\text{flight}} = v_0 \\cos\\theta \\cdot \\left(\\frac{2v_0 \\sin\\theta}{g}\\right) \\] \\[ \\boxed{R = \\frac{v_0^2 \\sin(2\\theta)}{g}} \\] This shows the range depends on \\( \\sin(2\\theta) \\) \u2014 maximum at \\( \\theta = 45^\\circ \\) . \ud83d\udcc8 2. Analysis of the Range \ud83d\udccc Insights: Maximum range occurs at \\( \\theta = 45^\\circ \\) For angles \\( \\theta \\) and \\( 90^\\circ - \\theta \\) , the range is the same The range increases with initial velocity \\( v_0 \\) , and decreases with gravity \\( g \\) \ud83d\udd27 3. Practical Applications This simple model works great when: - You launch from a flat surface - No air resistance But real life is messy! Consider: - Launch from a height (e.g., cliff or hill) - Uneven ground or slopes - Air drag (which heavily alters the trajectory) - Wind forces or spin (like a baseball or golf ball) In those cases, we\u2019d modify our model with: - Drag force: \\( F_d = -kv \\) - Numerical simulation (Euler or Runge-Kutta) \ud83d\udcbb 4. Implementation (Python Script) Let\u2019s implement a simulation and plot Range vs Angle for different velocities. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravity (m/s^2) angles = np.radians(np.linspace(0, 90, 500)) # angles in radians # Initial velocities to compare velocities = [10, 20, 30] # m/s plt.figure(figsize=(10, 6)) for v0 in velocities: ranges = (v0 ** 2) * np.sin(2 * angles) / g plt.plot(np.degrees(angles), ranges, label=f'v\u2080 = {v0} m/s') plt.title('Projectile Range vs Angle of Projection') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.show()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"We start with the equations of projectile motion , assuming: - No air resistance - Launched from ground level - Constant gravitational acceleration g = 9.81 m/s\u00b2","title":"\ud83d\udcd8 1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#basic-kinematic-equations","text":"Let a projectile be launched with: - Initial velocity: \\( v_0 \\) - Angle of projection: \\( \\theta \\) - From: \\( y_0 = 0 \\) Split into horizontal and vertical components: - \\( v_{x} = v_0 \\cos\\theta \\) - \\( v_{y} = v_0 \\sin\\theta \\)","title":"\u25b6\ufe0f Basic Kinematic Equations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight-when-projectile-returns-to-ground","text":"\\[ t_{\\text{flight}} = \\frac{2v_0 \\sin\\theta}{g} \\]","title":"Time of flight (when projectile returns to ground):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-range","text":"\\[ R = v_{x} \\cdot t_{\\text{flight}} = v_0 \\cos\\theta \\cdot \\left(\\frac{2v_0 \\sin\\theta}{g}\\right) \\] \\[ \\boxed{R = \\frac{v_0^2 \\sin(2\\theta)}{g}} \\] This shows the range depends on \\( \\sin(2\\theta) \\) \u2014 maximum at \\( \\theta = 45^\\circ \\) .","title":"Horizontal Range:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"\ud83d\udcc8 2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#insights","text":"Maximum range occurs at \\( \\theta = 45^\\circ \\) For angles \\( \\theta \\) and \\( 90^\\circ - \\theta \\) , the range is the same The range increases with initial velocity \\( v_0 \\) , and decreases with gravity \\( g \\)","title":"\ud83d\udccc Insights:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"This simple model works great when: - You launch from a flat surface - No air resistance But real life is messy! Consider: - Launch from a height (e.g., cliff or hill) - Uneven ground or slopes - Air drag (which heavily alters the trajectory) - Wind forces or spin (like a baseball or golf ball) In those cases, we\u2019d modify our model with: - Drag force: \\( F_d = -kv \\) - Numerical simulation (Euler or Runge-Kutta)","title":"\ud83d\udd27 3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-script","text":"Let\u2019s implement a simulation and plot Range vs Angle for different velocities. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravity (m/s^2) angles = np.radians(np.linspace(0, 90, 500)) # angles in radians # Initial velocities to compare velocities = [10, 20, 30] # m/s plt.figure(figsize=(10, 6)) for v0 in velocities: ranges = (v0 ** 2) * np.sin(2 * angles) / g plt.plot(np.degrees(angles), ranges, label=f'v\u2080 = {v0} m/s') plt.title('Projectile Range vs Angle of Projection') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.show()","title":"\ud83d\udcbb 4. Implementation (Python Script)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 \ud83c\udf00 Investigating the Dynamics of a Forced Damped Pendulum \ud83d\udcd8 1. Theoretical Foundation Equation of Motion The motion of a forced damped pendulum is described by the nonlinear second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] Where: - \\(\\theta(t)\\) : angular displacement - \\(\\gamma\\) : damping coefficient - \\(\\omega_0 = \\sqrt{g/L}\\) : natural angular frequency - \\(A\\) : amplitude of external forcing - \\(\\omega\\) : angular frequency of the driving force Small-Angle Approximation For small oscillations ( \\(\\theta \\ll 1\\) ), we use \\(\\sin\\theta \\approx \\theta\\) , simplifying the equation to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This is a driven damped harmonic oscillator , solvable analytically. General Solution (Small Angles) The solution consists of: - Transient (decays due to damping) - Steady-state (driven solution): \\[ \\theta(t) = \\theta_0 e^{-\\gamma t/2} \\cos(\\Omega t + \\phi) + B \\cos(\\omega t - \\delta) \\] Where: - \\(B = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (\\gamma \\omega)^2}}\\) - \\(\\delta = \\tan^{-1}\\left(\\frac{\\gamma \\omega}{\\omega_0^2 - \\omega^2}\\right)\\) Resonance Condition Occurs when driving frequency \\(\\omega \\approx \\omega_0\\) . - System absorbs maximum energy. - Amplitude \\(B\\) reaches a peak. - Damping reduces resonance sharpness. \ud83d\udd2c 2. Analysis of Dynamics Effect of Parameters Damping \\(\\gamma\\) : Low \\(\\gamma\\) : sustained oscillations. High \\(\\gamma\\) : motion dies out quickly. Driving Amplitude \\(A\\) : Small \\(A\\) : linear-like motion. Large \\(A\\) : complex, possibly chaotic behavior. Driving Frequency \\(\\omega\\) : Near resonance \u2192 large response. Far from resonance \u2192 low amplitude. Regular vs Chaotic Motion Regular : predictable, periodic or quasiperiodic. Chaotic : sensitive to initial conditions, irregular, non-repeating. Transition to chaos happens by increasing \\(A\\) or tuning \\(\\omega\\) . \ud83e\udde0 3. Real-World Applications Application Description \ud83c\udfd7\ufe0f Suspension Bridges External forcing (wind, traffic) causes oscillations \u26a1 RLC Circuits Analogous to pendulum with inductance/resistance \ud83d\udeb6 Biomechanics Human gait as forced pendulum \u2699\ufe0f Energy Harvesting Uses resonance for maximizing power \ud83d\udcbb 4. Python Implementation (Simulation) Below is a Python script using scipy and matplotlib . \ud83d\udd27 Required Libraries import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp \ud83d\udd01 Simulation Function # Parameters gamma = 0.1 # damping omega0 = 1.5 # natural frequency (sqrt(g/L)) A = 1.2 # driving amplitude omega = 2/3 # driving frequency def pendulum(t, y): theta, dtheta = y d2theta = -gamma * dtheta - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta, d2theta] \ud83e\uddea Solve the Equation # Initial conditions theta0 = 0.2 dtheta0 = 0.0 t_span = (0, 100) t_eval = np.linspace(*t_span, 5000) sol = solve_ivp(pendulum, t_span, [theta0, dtheta0], t_eval=t_eval) \ud83d\udcc8 Plot Time Evolution plt.figure(figsize=(10,4)) plt.plot(sol.t, sol.y[0], label='\u03b8(t)') plt.title('Forced Damped Pendulum - Angular Displacement Over Time') plt.xlabel('Time') plt.ylabel('Angle (rad)') plt.grid(True) plt.legend() plt.show() \ud83c\udf0c Phase Portrait plt.figure(figsize=(6,6)) plt.plot(sol.y[0], sol.y[1], lw=0.5) plt.title('Phase Portrait: \u03b8 vs d\u03b8/dt') plt.xlabel('\u03b8 (rad)') plt.ylabel('Angular velocity (rad/s)') plt.grid(True) plt.show() \ud83c\udf00 Poincar\u00e9 Section Sample the state every period of the driving force: T_drive = 2 * np.pi / omega sample_times = np.arange(0, 100, T_drive) theta_samples = [] omega_samples = [] for t_sample in sample_times: index = np.abs(sol.t - t_sample).argmin() theta_samples.append(sol.y[0][index]) omega_samples.append(sol.y[1][index]) plt.figure(figsize=(6,6)) plt.scatter(theta_samples, omega_samples, s=5) plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8 (rad)') plt.ylabel('d\u03b8/dt (rad/s)') plt.grid(True) plt.show() \ud83d\udcc9 5. Optional: Bifurcation Diagram Try plotting steady-state angle values for a range of amplitudes \\(A\\) : def get_bifurcation_data(A_values, omega=2/3): points = [] for A in A_values: def pend(t, y): theta, v = y return [v, -0.1 * v - 1.5**2 * np.sin(theta) + A * np.cos(omega * t)] sol = solve_ivp(pend, (0, 300), [0.1, 0], t_eval=np.linspace(200, 300, 1000)) T_drive = 2*np.pi / omega for t in np.arange(250, 300, T_drive): idx = np.abs(sol.t - t).argmin() points.append((A, sol.y[0][idx])) return points A_values = np.linspace(1.0, 1.5, 200) data = get_bifurcation_data(A_values) A_vals, theta_vals = zip(*data) plt.figure(figsize=(10,5)) plt.plot(A_vals, theta_vals, ',k') plt.title('Bifurcation Diagram: A vs \u03b8') plt.xlabel('Driving Amplitude A') plt.ylabel('\u03b8') plt.grid(True) plt.show() \ud83d\udea7 6. Limitations & Extensions Limitation Extension Assumes constant \\(\\gamma, A, \\omega\\) Add time-dependent forcing Only single pendulum Model coupled pendulums Idealized Add friction, noise, or nonlinear damping","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"\ud83c\udf00 Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"\ud83d\udcd8 1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#equation-of-motion","text":"The motion of a forced damped pendulum is described by the nonlinear second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] Where: - \\(\\theta(t)\\) : angular displacement - \\(\\gamma\\) : damping coefficient - \\(\\omega_0 = \\sqrt{g/L}\\) : natural angular frequency - \\(A\\) : amplitude of external forcing - \\(\\omega\\) : angular frequency of the driving force","title":"Equation of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations ( \\(\\theta \\ll 1\\) ), we use \\(\\sin\\theta \\approx \\theta\\) , simplifying the equation to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This is a driven damped harmonic oscillator , solvable analytically.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#general-solution-small-angles","text":"The solution consists of: - Transient (decays due to damping) - Steady-state (driven solution): \\[ \\theta(t) = \\theta_0 e^{-\\gamma t/2} \\cos(\\Omega t + \\phi) + B \\cos(\\omega t - \\delta) \\] Where: - \\(B = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (\\gamma \\omega)^2}}\\) - \\(\\delta = \\tan^{-1}\\left(\\frac{\\gamma \\omega}{\\omega_0^2 - \\omega^2}\\right)\\)","title":"General Solution (Small Angles)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"Occurs when driving frequency \\(\\omega \\approx \\omega_0\\) . - System absorbs maximum energy. - Amplitude \\(B\\) reaches a peak. - Damping reduces resonance sharpness.","title":"Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"\ud83d\udd2c 2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-parameters","text":"Damping \\(\\gamma\\) : Low \\(\\gamma\\) : sustained oscillations. High \\(\\gamma\\) : motion dies out quickly. Driving Amplitude \\(A\\) : Small \\(A\\) : linear-like motion. Large \\(A\\) : complex, possibly chaotic behavior. Driving Frequency \\(\\omega\\) : Near resonance \u2192 large response. Far from resonance \u2192 low amplitude.","title":"Effect of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#regular-vs-chaotic-motion","text":"Regular : predictable, periodic or quasiperiodic. Chaotic : sensitive to initial conditions, irregular, non-repeating. Transition to chaos happens by increasing \\(A\\) or tuning \\(\\omega\\) .","title":"Regular vs Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-real-world-applications","text":"Application Description \ud83c\udfd7\ufe0f Suspension Bridges External forcing (wind, traffic) causes oscillations \u26a1 RLC Circuits Analogous to pendulum with inductance/resistance \ud83d\udeb6 Biomechanics Human gait as forced pendulum \u2699\ufe0f Energy Harvesting Uses resonance for maximizing power","title":"\ud83e\udde0 3. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-python-implementation-simulation","text":"Below is a Python script using scipy and matplotlib .","title":"\ud83d\udcbb 4. Python Implementation (Simulation)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#required-libraries","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp","title":"\ud83d\udd27 Required Libraries"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#simulation-function","text":"# Parameters gamma = 0.1 # damping omega0 = 1.5 # natural frequency (sqrt(g/L)) A = 1.2 # driving amplitude omega = 2/3 # driving frequency def pendulum(t, y): theta, dtheta = y d2theta = -gamma * dtheta - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta, d2theta]","title":"\ud83d\udd01 Simulation Function"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#solve-the-equation","text":"# Initial conditions theta0 = 0.2 dtheta0 = 0.0 t_span = (0, 100) t_eval = np.linspace(*t_span, 5000) sol = solve_ivp(pendulum, t_span, [theta0, dtheta0], t_eval=t_eval)","title":"\ud83e\uddea Solve the Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#plot-time-evolution","text":"plt.figure(figsize=(10,4)) plt.plot(sol.t, sol.y[0], label='\u03b8(t)') plt.title('Forced Damped Pendulum - Angular Displacement Over Time') plt.xlabel('Time') plt.ylabel('Angle (rad)') plt.grid(True) plt.legend() plt.show()","title":"\ud83d\udcc8 Plot Time Evolution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#phase-portrait","text":"plt.figure(figsize=(6,6)) plt.plot(sol.y[0], sol.y[1], lw=0.5) plt.title('Phase Portrait: \u03b8 vs d\u03b8/dt') plt.xlabel('\u03b8 (rad)') plt.ylabel('Angular velocity (rad/s)') plt.grid(True) plt.show()","title":"\ud83c\udf0c Phase Portrait"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#poincare-section","text":"Sample the state every period of the driving force: T_drive = 2 * np.pi / omega sample_times = np.arange(0, 100, T_drive) theta_samples = [] omega_samples = [] for t_sample in sample_times: index = np.abs(sol.t - t_sample).argmin() theta_samples.append(sol.y[0][index]) omega_samples.append(sol.y[1][index]) plt.figure(figsize=(6,6)) plt.scatter(theta_samples, omega_samples, s=5) plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8 (rad)') plt.ylabel('d\u03b8/dt (rad/s)') plt.grid(True) plt.show()","title":"\ud83c\udf00 Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-optional-bifurcation-diagram","text":"Try plotting steady-state angle values for a range of amplitudes \\(A\\) : def get_bifurcation_data(A_values, omega=2/3): points = [] for A in A_values: def pend(t, y): theta, v = y return [v, -0.1 * v - 1.5**2 * np.sin(theta) + A * np.cos(omega * t)] sol = solve_ivp(pend, (0, 300), [0.1, 0], t_eval=np.linspace(200, 300, 1000)) T_drive = 2*np.pi / omega for t in np.arange(250, 300, T_drive): idx = np.abs(sol.t - t).argmin() points.append((A, sol.y[0][idx])) return points A_values = np.linspace(1.0, 1.5, 200) data = get_bifurcation_data(A_values) A_vals, theta_vals = zip(*data) plt.figure(figsize=(10,5)) plt.plot(A_vals, theta_vals, ',k') plt.title('Bifurcation Diagram: A vs \u03b8') plt.xlabel('Driving Amplitude A') plt.ylabel('\u03b8') plt.grid(True) plt.show()","title":"\ud83d\udcc9 5. Optional: Bifurcation Diagram"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-limitations-extensions","text":"Limitation Extension Assumes constant \\(\\gamma, A, \\omega\\) Add time-dependent forcing Only single pendulum Model coupled pendulums Idealized Add friction, noise, or nonlinear damping","title":"\ud83d\udea7 6. Limitations &amp; Extensions"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 \ud83d\udcd8 1. Theoretical Derivation We begin with Newton\u2019s Law of Gravitation and centripetal force for an object in circular orbit . \ud83e\udde0 Newton\u2019s Law of Universal Gravitation: \\[ F = \\frac{G M m}{r^2} \\] Where: - \\( F \\) : gravitational force - \\( G \\) : gravitational constant \\(6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2\\) - \\( M \\) : mass of central body (e.g., Earth or Sun) - \\( m \\) : mass of orbiting body - \\( r \\) : orbital radius \ud83c\udf00 Centripetal Force for Circular Orbit: \\[ F = \\frac{m v^2}{r} \\] Set the two forces equal: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancel \\( m \\) and solve for orbital velocity \\( v \\) : \\[ v^2 = \\frac{G M}{r} \\] Now recall: [ v = \\frac{2\\pi r}{T} ] Plug into velocity equation: \\[ \\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{G M}{r} \\] \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Multiply both sides by \\( T^2 r \\) : \\[ 4\\pi^2 r^3 = G M T^2 \\] Now solve for \\( T^2 \\) : \\[ \\boxed{T^2 = \\frac{4\\pi^2}{G M} \\cdot r^3} \\] This is Kepler\u2019s Third Law \u2014 the square of the orbital period is proportional to the cube of the orbital radius . \ud83c\udf0c 2. Implications for Astronomy Helps determine distances to planets (e.g. using their periods) Lets us calculate mass of celestial bodies by rearranging the formula Applies to moons , planets , satellites , even binary stars \ud83c\udf0d 3. Real-World Example: The Moon Let\u2019s apply Kepler\u2019s Law to the Moon orbiting Earth. Orbital radius \\( r = 384,400 \\) km = \\( 3.844 \\times 10^8 \\) m Mass of Earth \\( M = 5.972 \\times 10^{24} \\) kg We\u2019ll plug into: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] \ud83d\udcbb 4. Python Simulation & Plot Let\u2019s write Python code to: Simulate planets with different orbital radii Calculate orbital periods Plot \\( T^2 \\) vs \\( r^3 \\) to verify linear relationship import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth in kg # Orbital radii in meters (from 1e7 m to 5e8 m) radii = np.linspace(1e7, 5e8, 100) # Calculate orbital periods T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Kepler's law verification: T^2 vs r^3 T_squared = T**2 r_cubed = radii**3 # Plotting plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, label=\"Kepler's Third Law Verified\", color='purple') plt.xlabel(\"Orbital Radius\u00b3 (m\u00b3)\") plt.ylabel(\"Orbital Period\u00b2 (s\u00b2)\") plt.title(\"Kepler's Third Law: $T^2 \\\\propto r^3$\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() \ud83d\udcca Deliverables Recap \u2705 Derivation : Kepler\u2019s 3rd Law from Newtonian gravity \u2705 Applications : Planetary motion, satellites, moon orbits \u2705 Simulation : Period vs Radius in Python \u2705 Plot : Linear relationship between \\( T^2 \\) and \\( r^3 \\)","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-derivation","text":"We begin with Newton\u2019s Law of Gravitation and centripetal force for an object in circular orbit .","title":"\ud83d\udcd8 1. Theoretical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#newtons-law-of-universal-gravitation","text":"\\[ F = \\frac{G M m}{r^2} \\] Where: - \\( F \\) : gravitational force - \\( G \\) : gravitational constant \\(6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2\\) - \\( M \\) : mass of central body (e.g., Earth or Sun) - \\( m \\) : mass of orbiting body - \\( r \\) : orbital radius","title":"\ud83e\udde0 Newton\u2019s Law of Universal Gravitation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#centripetal-force-for-circular-orbit","text":"\\[ F = \\frac{m v^2}{r} \\] Set the two forces equal: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancel \\( m \\) and solve for orbital velocity \\( v \\) : \\[ v^2 = \\frac{G M}{r} \\] Now recall: [ v = \\frac{2\\pi r}{T} ] Plug into velocity equation: \\[ \\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{G M}{r} \\] \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Multiply both sides by \\( T^2 r \\) : \\[ 4\\pi^2 r^3 = G M T^2 \\] Now solve for \\( T^2 \\) : \\[ \\boxed{T^2 = \\frac{4\\pi^2}{G M} \\cdot r^3} \\] This is Kepler\u2019s Third Law \u2014 the square of the orbital period is proportional to the cube of the orbital radius .","title":"\ud83c\udf00 Centripetal Force for Circular Orbit:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"Helps determine distances to planets (e.g. using their periods) Lets us calculate mass of celestial bodies by rearranging the formula Applies to moons , planets , satellites , even binary stars","title":"\ud83c\udf0c 2. Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-example-the-moon","text":"Let\u2019s apply Kepler\u2019s Law to the Moon orbiting Earth. Orbital radius \\( r = 384,400 \\) km = \\( 3.844 \\times 10^8 \\) m Mass of Earth \\( M = 5.972 \\times 10^{24} \\) kg We\u2019ll plug into: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\]","title":"\ud83c\udf0d 3. Real-World Example: The Moon"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-python-simulation-plot","text":"Let\u2019s write Python code to: Simulate planets with different orbital radii Calculate orbital periods Plot \\( T^2 \\) vs \\( r^3 \\) to verify linear relationship import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth in kg # Orbital radii in meters (from 1e7 m to 5e8 m) radii = np.linspace(1e7, 5e8, 100) # Calculate orbital periods T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Kepler's law verification: T^2 vs r^3 T_squared = T**2 r_cubed = radii**3 # Plotting plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, label=\"Kepler's Third Law Verified\", color='purple') plt.xlabel(\"Orbital Radius\u00b3 (m\u00b3)\") plt.ylabel(\"Orbital Period\u00b2 (s\u00b2)\") plt.title(\"Kepler's Third Law: $T^2 \\\\propto r^3$\") plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"\ud83d\udcbb 4. Python Simulation &amp; Plot"},{"location":"1%20Physics/2%20Gravity/Problem_1/#deliverables-recap","text":"\u2705 Derivation : Kepler\u2019s 3rd Law from Newtonian gravity \u2705 Applications : Planetary motion, satellites, moon orbits \u2705 Simulation : Period vs Radius in Python \u2705 Plot : Linear relationship between \\( T^2 \\) and \\( r^3 \\)","title":"\ud83d\udcca Deliverables Recap"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 \ud83d\ude80 1. Defining the Cosmic Velocities These velocities are thresholds for different types of motion under gravity. First Cosmic Velocity (Orbital Velocity) Definition : Minimum speed needed to enter low circular orbit around a planet (just above the surface). Meaning : Object doesn't fall back \u2014 it falls around the planet. \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Second Cosmic Velocity (Escape Velocity) Definition : Minimum speed to completely escape the gravity of a planet. Meaning : Object never returns unless acted on. \\[ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{r}} \\] Third Cosmic Velocity (Interstellar Escape) Definition : Minimum speed to escape the Solar System , from Earth orbit. Meaning : Object escapes Sun\u2019s gravity starting from a planet like Earth. \\[ v_3 = \\sqrt{v_{\\text{esc,Sun}}^2 + v_{\\text{orb,Earth}}^2} \\] Where: - \\( v_{\\text{esc,Sun}} \\) : escape velocity from the Sun at Earth\u2019s orbit - \\( v_{\\text{orb,Earth}} \\) : Earth\u2019s orbital speed around the Sun \ud83e\udde0 2. Derivation of Escape Velocity From energy conservation: \\[ \\text{Kinetic energy} = \\text{Gravitational potential energy} \\] \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\Rightarrow v = \\sqrt{\\frac{2GM}{r}} \\] Where: - \\( G \\) : gravitational constant = \\(6.67430 \\times 10^{-11} \\) - \\( M \\) : mass of the planet/star - \\( r \\) : distance from center of mass \ud83c\udf0d 3. Examples for Earth, Mars, Jupiter Let\u2019s compute the 3 cosmic velocities for Earth, Mars, and Jupiter: Planet Mass (kg) Radius (m) Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) Mars \\(6.417 \\times 10^{23}\\) \\(3.390 \\times 10^6\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.991 \\times 10^7\\) \ud83d\udcbb 4. Python Simulation and Visualization Here\u2019s Python code to calculate and visualize cosmic velocities: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 # Planet data: name, mass (kg), radius (m) planets = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.390e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.991e7} } # Calculate velocities results = {} for planet, data in planets.items(): M = data[\"mass\"] r = data[\"radius\"] v1 = np.sqrt(G * M / r) # First cosmic (orbital) v2 = np.sqrt(2 * G * M / r) # Second cosmic (escape) results[planet] = { \"v1_kms\": v1 / 1000, \"v2_kms\": v2 / 1000 } # Plotting labels = list(results.keys()) v1_vals = [results[p][\"v1_kms\"] for p in labels] v2_vals = [results[p][\"v2_kms\"] for p in labels] x = np.arange(len(labels)) width = 0.35 plt.figure(figsize=(10,6)) plt.bar(x - width/2, v1_vals, width, label=\"1st Cosmic Velocity (Orbital)\") plt.bar(x + width/2, v2_vals, width, label=\"2nd Cosmic Velocity (Escape)\") plt.xticks(x, labels) plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities for Planets\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() \ud83d\udcca Deliverables Recap \u2705 Markdown or Notebook : With theory + code \u2705 Equations : For each cosmic velocity \u2705 Calculations : For Earth, Mars, and Jupiter \u2705 Graph : Comparing velocities across planets \u2705 Extension : Third cosmic velocity (leaving the Solar System)","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-defining-the-cosmic-velocities","text":"These velocities are thresholds for different types of motion under gravity.","title":"\ud83d\ude80 1. Defining the Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"Definition : Minimum speed needed to enter low circular orbit around a planet (just above the surface). Meaning : Object doesn't fall back \u2014 it falls around the planet. \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\]","title":"First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"Definition : Minimum speed to completely escape the gravity of a planet. Meaning : Object never returns unless acted on. \\[ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{r}} \\]","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-interstellar-escape","text":"Definition : Minimum speed to escape the Solar System , from Earth orbit. Meaning : Object escapes Sun\u2019s gravity starting from a planet like Earth. \\[ v_3 = \\sqrt{v_{\\text{esc,Sun}}^2 + v_{\\text{orb,Earth}}^2} \\] Where: - \\( v_{\\text{esc,Sun}} \\) : escape velocity from the Sun at Earth\u2019s orbit - \\( v_{\\text{orb,Earth}} \\) : Earth\u2019s orbital speed around the Sun","title":"Third Cosmic Velocity (Interstellar Escape)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-derivation-of-escape-velocity","text":"From energy conservation: \\[ \\text{Kinetic energy} = \\text{Gravitational potential energy} \\] \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\Rightarrow v = \\sqrt{\\frac{2GM}{r}} \\] Where: - \\( G \\) : gravitational constant = \\(6.67430 \\times 10^{-11} \\) - \\( M \\) : mass of the planet/star - \\( r \\) : distance from center of mass","title":"\ud83e\udde0 2. Derivation of Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-examples-for-earth-mars-jupiter","text":"Let\u2019s compute the 3 cosmic velocities for Earth, Mars, and Jupiter: Planet Mass (kg) Radius (m) Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) Mars \\(6.417 \\times 10^{23}\\) \\(3.390 \\times 10^6\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.991 \\times 10^7\\)","title":"\ud83c\udf0d 3. Examples for Earth, Mars, Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-python-simulation-and-visualization","text":"Here\u2019s Python code to calculate and visualize cosmic velocities: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 # Planet data: name, mass (kg), radius (m) planets = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.390e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.991e7} } # Calculate velocities results = {} for planet, data in planets.items(): M = data[\"mass\"] r = data[\"radius\"] v1 = np.sqrt(G * M / r) # First cosmic (orbital) v2 = np.sqrt(2 * G * M / r) # Second cosmic (escape) results[planet] = { \"v1_kms\": v1 / 1000, \"v2_kms\": v2 / 1000 } # Plotting labels = list(results.keys()) v1_vals = [results[p][\"v1_kms\"] for p in labels] v2_vals = [results[p][\"v2_kms\"] for p in labels] x = np.arange(len(labels)) width = 0.35 plt.figure(figsize=(10,6)) plt.bar(x - width/2, v1_vals, width, label=\"1st Cosmic Velocity (Orbital)\") plt.bar(x + width/2, v2_vals, width, label=\"2nd Cosmic Velocity (Escape)\") plt.xticks(x, labels) plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities for Planets\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"\ud83d\udcbb 4. Python Simulation and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#deliverables-recap","text":"\u2705 Markdown or Notebook : With theory + code \u2705 Equations : For each cosmic velocity \u2705 Calculations : For Earth, Mars, and Jupiter \u2705 Graph : Comparing velocities across planets \u2705 Extension : Third cosmic velocity (leaving the Solar System)","title":"\ud83d\udcca Deliverables Recap"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 \ud83c\udf0d 1. Theoretical Overview: Payload Trajectories Near Earth Types of Trajectories: When a payload is released from a moving spacecraft near Earth, its trajectory depends on its initial velocity vector relative to Earth. It will follow one of these conic sections: Type Speed Relative to Escape Velocity Orbit Shape Circular Exactly orbital speed Circle Elliptical Less than escape speed Ellipse Parabolic Exactly escape speed Parabola Hyperbolic Greater than escape speed Hyperbola Suborbital Too low to complete an orbit Falls to Earth \u2699\ufe0f 2. Governing Equations Newton\u2019s Law of Gravitation: \\[ \\vec{F} = - \\frac{G M m}{r^2} \\hat{r} \\] This leads to an acceleration toward Earth\u2019s center: [ \\vec{a} = -\\frac{G M}{r^2} \\hat{r} ] Where: - \\( G = 6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) - \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) - \\( r \\) : distance from Earth's center - \\( \\hat{r} \\) : unit vector pointing from object to Earth's center We\u2019ll numerically solve: \\( \\frac{d\\vec{v}}{dt} = \\vec{a} \\) \\( \\frac{d\\vec{r}}{dt} = \\vec{v} \\) Using the Euler or RK4 method. \ud83d\udcca 3. Python Simulation: Visualizing Payload Trajectories We'll use this to simulate the motion of a payload from different speeds at a set altitude. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Mass of Earth R_earth = 6.371e6 # Radius of Earth (m) # Simulation parameters dt = 1 # time step (s) total_time = 10000 # total simulation time (s) steps = int(total_time / dt) def simulate_trajectory(v0, angle_deg, altitude): # Initial conditions r0 = R_earth + altitude theta = np.radians(angle_deg) pos = np.array([r0, 0]) vel = v0 * np.array([0, 1]) # Launch tangentially positions = [] for _ in range(steps): r = np.linalg.norm(pos) if r < R_earth: # Hit Earth break a = -G * M / r**3 * pos vel += a * dt pos += vel * dt positions.append(pos.copy()) return np.array(positions) # Simulate various speeds at 300 km altitude altitude = 300e3 v_circular = np.sqrt(G * M / (R_earth + altitude)) v_escape = np.sqrt(2) * v_circular velocities = [0.8 * v_circular, v_circular, 1.1 * v_circular, v_escape] labels = ['Suborbital', 'Circular', 'Elliptical', 'Escape'] # Plotting plt.figure(figsize=(8, 8)) for v, label in zip(velocities, labels): traj = simulate_trajectory(v, 90, altitude) plt.plot(traj[:,0]/1e6, traj[:,1]/1e6, label=label) # Draw Earth earth = plt.Circle((0, 0), R_earth/1e6, color='skyblue', alpha=0.5) plt.gca().add_patch(earth) plt.xlabel(\"x position (Mm)\") plt.ylabel(\"y position (Mm)\") plt.title(\"Payload Trajectories from Low Earth Orbit\") plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Here's the plot showing different payload trajectories from a 300 km altitude, based on varying initial velocities: Suborbital: Falls back to Earth. Circular: Achieves stable orbit. Elliptical: Enters an elongated orbit. Escape: Exceeds escape velocity and leaves Earth's gravity. \ud83d\udcd8 4. Key Observations Speeds < orbital velocity \u2192 payload returns to Earth (suborbital) Speed = orbital \u2192 stable circular orbit Speed > orbital, < escape \u2192 elliptical orbit Speed = escape \u2192 parabolic escape Speed > escape \u2192 hyperbolic escape \ud83d\udcbc 5. Applications Use Case Trajectory Type Launching Satellites Circular/Elliptical Space Station Supply Elliptical/Rendezvous Moon Mission / Interplanetary Escape / Hyperbolic Returning to Earth Suborbital/Reentry \ud83d\udcc2 Deliverables Recap \u2705 Markdown/Notebook : With equations, explanations, and Python \u2705 Numerical Simulation : Integrates motion under gravity \u2705 Trajectories : Suborbital, circular, elliptical, escape \u2705 Real-world Link : Relates directly to space missions","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-theoretical-overview-payload-trajectories-near-earth","text":"","title":"\ud83c\udf0d 1. Theoretical Overview: Payload Trajectories Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"When a payload is released from a moving spacecraft near Earth, its trajectory depends on its initial velocity vector relative to Earth. It will follow one of these conic sections: Type Speed Relative to Escape Velocity Orbit Shape Circular Exactly orbital speed Circle Elliptical Less than escape speed Ellipse Parabolic Exactly escape speed Parabola Hyperbolic Greater than escape speed Hyperbola Suborbital Too low to complete an orbit Falls to Earth","title":"Types of Trajectories:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-governing-equations","text":"","title":"\u2699\ufe0f 2. Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-gravitation","text":"\\[ \\vec{F} = - \\frac{G M m}{r^2} \\hat{r} \\] This leads to an acceleration toward Earth\u2019s center: [ \\vec{a} = -\\frac{G M}{r^2} \\hat{r} ] Where: - \\( G = 6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) - \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) - \\( r \\) : distance from Earth's center - \\( \\hat{r} \\) : unit vector pointing from object to Earth's center","title":"Newton\u2019s Law of Gravitation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#well-numerically-solve","text":"\\( \\frac{d\\vec{v}}{dt} = \\vec{a} \\) \\( \\frac{d\\vec{r}}{dt} = \\vec{v} \\) Using the Euler or RK4 method.","title":"We\u2019ll numerically solve:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-python-simulation-visualizing-payload-trajectories","text":"We'll use this to simulate the motion of a payload from different speeds at a set altitude. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Mass of Earth R_earth = 6.371e6 # Radius of Earth (m) # Simulation parameters dt = 1 # time step (s) total_time = 10000 # total simulation time (s) steps = int(total_time / dt) def simulate_trajectory(v0, angle_deg, altitude): # Initial conditions r0 = R_earth + altitude theta = np.radians(angle_deg) pos = np.array([r0, 0]) vel = v0 * np.array([0, 1]) # Launch tangentially positions = [] for _ in range(steps): r = np.linalg.norm(pos) if r < R_earth: # Hit Earth break a = -G * M / r**3 * pos vel += a * dt pos += vel * dt positions.append(pos.copy()) return np.array(positions) # Simulate various speeds at 300 km altitude altitude = 300e3 v_circular = np.sqrt(G * M / (R_earth + altitude)) v_escape = np.sqrt(2) * v_circular velocities = [0.8 * v_circular, v_circular, 1.1 * v_circular, v_escape] labels = ['Suborbital', 'Circular', 'Elliptical', 'Escape'] # Plotting plt.figure(figsize=(8, 8)) for v, label in zip(velocities, labels): traj = simulate_trajectory(v, 90, altitude) plt.plot(traj[:,0]/1e6, traj[:,1]/1e6, label=label) # Draw Earth earth = plt.Circle((0, 0), R_earth/1e6, color='skyblue', alpha=0.5) plt.gca().add_patch(earth) plt.xlabel(\"x position (Mm)\") plt.ylabel(\"y position (Mm)\") plt.title(\"Payload Trajectories from Low Earth Orbit\") plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Here's the plot showing different payload trajectories from a 300 km altitude, based on varying initial velocities: Suborbital: Falls back to Earth. Circular: Achieves stable orbit. Elliptical: Enters an elongated orbit.","title":"\ud83d\udcca 3. Python Simulation: Visualizing Payload Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-exceeds-escape-velocity-and-leaves-earths-gravity","text":"","title":"Escape: Exceeds escape velocity and leaves Earth's gravity."},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-key-observations","text":"Speeds < orbital velocity \u2192 payload returns to Earth (suborbital) Speed = orbital \u2192 stable circular orbit Speed > orbital, < escape \u2192 elliptical orbit Speed = escape \u2192 parabolic escape Speed > escape \u2192 hyperbolic escape","title":"\ud83d\udcd8 4. Key Observations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-applications","text":"Use Case Trajectory Type Launching Satellites Circular/Elliptical Space Station Supply Elliptical/Rendezvous Moon Mission / Interplanetary Escape / Hyperbolic Returning to Earth Suborbital/Reentry","title":"\ud83d\udcbc 5. Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#deliverables-recap","text":"\u2705 Markdown/Notebook : With equations, explanations, and Python \u2705 Numerical Simulation : Integrates motion under gravity \u2705 Trajectories : Suborbital, circular, elliptical, escape \u2705 Real-world Link : Relates directly to space missions","title":"\ud83d\udcc2 Deliverables Recap"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 \ud83d\udd0d Overview of the Task We will: 1. Choose a regular polygon (we\u2019ll start with a square for simplicity). 2. Place identical wave sources at each vertex. 3. Use the wave function: [ \\psi_i(x, y, t) = A \\cdot \\sin(k r_i - \\omega t + \\phi) ] where: - \\( A \\) : Amplitude - \\( k = \\frac{2\\pi}{\\lambda} \\) : Wave number - \\( \\omega = 2\\pi f \\) : Angular frequency - \\( r_i = \\text{distance from source } i \\text{ to point } (x, y) \\) - \\( \\phi \\) : Initial phase (same for coherence) 4. Superimpose all waves: [ \\Psi(x, y, t) = \\sum_{i=1}^{N} \\psi_i(x, y, t) ] 5. Visualize the resulting surface at a given time \\( t \\) , showing constructive and destructive interference . \u2699\ufe0f Python Simulation Code Here\u2019s a clean and interactive Python simulation: import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1.0 # Amplitude \u03bb = 2.0 # Wavelength f = 1.0 # Frequency k = 2 * np.pi / \u03bb # Wave number \u03c9 = 2 * np.pi * f # Angular frequency \u03c6 = 0 # Phase (coherent sources) t = 0 # Fixed time snapshot # Grid setup x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Polygon source placement (Square) def regular_polygon_vertices(n_sides, radius=5.0): angles = np.linspace(0, 2 * np.pi, n_sides, endpoint=False) return np.array([[radius * np.cos(a), radius * np.sin(a)] for a in angles]) # Number of sources and their positions N = 4 # Square sources = regular_polygon_vertices(N) # Superposition of waves from each source def wave_sum(X, Y, sources, t): result = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) result += A * np.sin(k * r - \u03c9 * t + \u03c6) return result # Calculate the wave pattern at time t Z = wave_sum(X, Y, sources, t) # Plotting the interference pattern plt.figure(figsize=(8, 8)) plt.pcolormesh(X, Y, Z, shading='auto', cmap='seismic') plt.colorbar(label='Wave Amplitude') plt.scatter(sources[:,0], sources[:,1], color='black', label='Wave Sources') plt.title(\"Water Wave Interference Pattern (Square Configuration)\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.legend() plt.axis('equal') plt.grid(False) plt.show() \ud83d\udcd8 Explanation of the Pattern Constructive interference : Where waves from different sources arrive in phase , their amplitudes add up, forming bright ridges in the plot. Destructive interference : Where they arrive out of phase , they cancel out, forming dark nodes . Due to symmetry (square in this case), the pattern reflects the polygon shape and produces radial and circular symmetry . \ud83d\udcc8 Deliverables Recap \u2705 Markdown + Python Notebook : Done above \u2705 Mathematical model : Superposition of sinusoidal point waves \u2705 Simulation : Based on position + time snapshot \u2705 Visualization : Interference pattern with color map \u2705 Analysis : - Patterns are periodic - Sensitive to number of sources - Show clearly how wave interference works","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#overview-of-the-task","text":"We will: 1. Choose a regular polygon (we\u2019ll start with a square for simplicity). 2. Place identical wave sources at each vertex. 3. Use the wave function: [ \\psi_i(x, y, t) = A \\cdot \\sin(k r_i - \\omega t + \\phi) ] where: - \\( A \\) : Amplitude - \\( k = \\frac{2\\pi}{\\lambda} \\) : Wave number - \\( \\omega = 2\\pi f \\) : Angular frequency - \\( r_i = \\text{distance from source } i \\text{ to point } (x, y) \\) - \\( \\phi \\) : Initial phase (same for coherence) 4. Superimpose all waves: [ \\Psi(x, y, t) = \\sum_{i=1}^{N} \\psi_i(x, y, t) ] 5. Visualize the resulting surface at a given time \\( t \\) , showing constructive and destructive interference .","title":"\ud83d\udd0d Overview of the Task"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-simulation-code","text":"Here\u2019s a clean and interactive Python simulation: import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1.0 # Amplitude \u03bb = 2.0 # Wavelength f = 1.0 # Frequency k = 2 * np.pi / \u03bb # Wave number \u03c9 = 2 * np.pi * f # Angular frequency \u03c6 = 0 # Phase (coherent sources) t = 0 # Fixed time snapshot # Grid setup x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Polygon source placement (Square) def regular_polygon_vertices(n_sides, radius=5.0): angles = np.linspace(0, 2 * np.pi, n_sides, endpoint=False) return np.array([[radius * np.cos(a), radius * np.sin(a)] for a in angles]) # Number of sources and their positions N = 4 # Square sources = regular_polygon_vertices(N) # Superposition of waves from each source def wave_sum(X, Y, sources, t): result = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) result += A * np.sin(k * r - \u03c9 * t + \u03c6) return result # Calculate the wave pattern at time t Z = wave_sum(X, Y, sources, t) # Plotting the interference pattern plt.figure(figsize=(8, 8)) plt.pcolormesh(X, Y, Z, shading='auto', cmap='seismic') plt.colorbar(label='Wave Amplitude') plt.scatter(sources[:,0], sources[:,1], color='black', label='Wave Sources') plt.title(\"Water Wave Interference Pattern (Square Configuration)\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.legend() plt.axis('equal') plt.grid(False) plt.show()","title":"\u2699\ufe0f Python Simulation Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#explanation-of-the-pattern","text":"Constructive interference : Where waves from different sources arrive in phase , their amplitudes add up, forming bright ridges in the plot. Destructive interference : Where they arrive out of phase , they cancel out, forming dark nodes . Due to symmetry (square in this case), the pattern reflects the polygon shape and produces radial and circular symmetry .","title":"\ud83d\udcd8 Explanation of the Pattern"},{"location":"1%20Physics/3%20Waves/Problem_1/#deliverables-recap","text":"\u2705 Markdown + Python Notebook : Done above \u2705 Mathematical model : Superposition of sinusoidal point waves \u2705 Simulation : Based on position + time snapshot \u2705 Visualization : Interference pattern with color map \u2705 Analysis : - Patterns are periodic - Sensitive to number of sources - Show clearly how wave interference works","title":"\ud83d\udcc8 Deliverables Recap"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 \ud83e\uddf2 1. The Lorentz Force The Lorentz force is given by: [ \\vec{F} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) ] Where: - \\( \\vec{F} \\) : Force on a particle - \\( q \\) : Charge of the particle - \\( \\vec{v} \\) : Velocity - \\( \\vec{E} \\) : Electric field - \\( \\vec{B} \\) : Magnetic field This force governs the motion of charged particles in electric and magnetic fields \u2014 seen in plasma physics , mass spectrometry , cyclotrons , fusion reactors , etc. \ud83e\uddee 2. Simulation Strategy We solve Newton\u2019s second law: [ m \\frac{d\\vec{v}}{dt} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) ] Use numerical integration (e.g., Euler or RK4 ) to compute the path. \ud83e\uddea 3. Python Simulation: Charged Particle in Uniform \\( \\vec{B} \\) and \\( \\vec{E} \\) We\u2019ll start with: - A uniform magnetic field \\( \\vec{B} = B \\hat{z} \\) - Optional electric field \\( \\vec{E} = E \\hat{y} \\) - Initial velocity \\( \\vec{v}_0 \\) \u2705 Basic Configuration import numpy as np import matplotlib.pyplot as plt # Physical constants q = 1.6e-19 # charge of particle (C) m = 9.11e-31 # mass of particle (kg) B = np.array([0, 0, 1.0]) # magnetic field (T) E = np.array([0.0, 0.0, 0.0]) # electric field (V/m) # Initial conditions v0 = np.array([1e6, 0.0, 0.0]) # initial velocity (m/s) r0 = np.array([0.0, 0.0, 0.0]) # initial position (m) # Simulation parameters dt = 1e-11 # time step (s) steps = 2000 # number of steps # Storage positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) r = r0.copy() v = v0.copy() # Numerical integration (Euler) for i in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt positions[i] = r velocities[i] = v The simulation attempted to model a charged particle's motion in a magnetic field, but it ran into a numerical overflow due to the extremely high acceleration. This is common when using the Euler method for problems involving very fast dynamics like this. \ud83d\udcca 4. Visualization 2D View (e.g., x-y plane motion): plt.figure(figsize=(8, 6)) plt.plot(positions[:, 0], positions[:, 1]) plt.title('Charged Particle Trajectory in Magnetic Field (XY Plane)') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') plt.grid(True) plt.show() 3D Trajectory (if motion in z is involved): from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:,0], positions[:,1], positions[:,2]) ax.set_title('3D Trajectory of Charged Particle') ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') plt.show() \ud83c\udf00 5. What You\u2019ll Observe With only \\( \\vec{B} \\) and initial perpendicular \\( \\vec{v} \\) : the particle makes a circular path (due to centripetal magnetic force). Add a parallel \\( \\vec{v}_z \\) : helical trajectory . Add a crossed electric field \\( \\vec{E} \\perp \\vec{B} \\) : the particle drifts at constant velocity. \ud83d\udd0d Larmor radius: \\[ r_L = \\frac{mv_\\perp}{|q|B} \\] \ud83d\udd01 Cyclotron frequency: \\[ \\omega_c = \\frac{|q|B}{m} \\] \ud83d\udd04 6. Parameter Exploration Try modifying: - Mass/charge (e.g., electrons vs protons ) - Magnetic field direction or strength - Electric field strength - Initial velocity angle (see circular vs helical paths) - Try crossed E and B fields to show E\u00d7B drift \ud83d\udce6 7. Deliverables Recap \u2705 Python simulation of charged particle motion under Lorentz force \u2705 2D and 3D trajectory plots \u2705 Physical explanations (e.g., cyclotron motion, drift, helices) \u2705 Ready to export as Markdown or Jupyter Notebook \u2705 Links to real systems like cyclotrons, Hall thrusters, and plasma containment ssss","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-the-lorentz-force","text":"The Lorentz force is given by: [ \\vec{F} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) ] Where: - \\( \\vec{F} \\) : Force on a particle - \\( q \\) : Charge of the particle - \\( \\vec{v} \\) : Velocity - \\( \\vec{E} \\) : Electric field - \\( \\vec{B} \\) : Magnetic field This force governs the motion of charged particles in electric and magnetic fields \u2014 seen in plasma physics , mass spectrometry , cyclotrons , fusion reactors , etc.","title":"\ud83e\uddf2 1. The Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulation-strategy","text":"We solve Newton\u2019s second law: [ m \\frac{d\\vec{v}}{dt} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) ] Use numerical integration (e.g., Euler or RK4 ) to compute the path.","title":"\ud83e\uddee 2. Simulation Strategy"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-python-simulation-charged-particle-in-uniform-vecb-and-vece","text":"We\u2019ll start with: - A uniform magnetic field \\( \\vec{B} = B \\hat{z} \\) - Optional electric field \\( \\vec{E} = E \\hat{y} \\) - Initial velocity \\( \\vec{v}_0 \\)","title":"\ud83e\uddea 3. Python Simulation: Charged Particle in Uniform \\( \\vec{B} \\) and \\( \\vec{E} \\)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#basic-configuration","text":"import numpy as np import matplotlib.pyplot as plt # Physical constants q = 1.6e-19 # charge of particle (C) m = 9.11e-31 # mass of particle (kg) B = np.array([0, 0, 1.0]) # magnetic field (T) E = np.array([0.0, 0.0, 0.0]) # electric field (V/m) # Initial conditions v0 = np.array([1e6, 0.0, 0.0]) # initial velocity (m/s) r0 = np.array([0.0, 0.0, 0.0]) # initial position (m) # Simulation parameters dt = 1e-11 # time step (s) steps = 2000 # number of steps # Storage positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) r = r0.copy() v = v0.copy() # Numerical integration (Euler) for i in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt positions[i] = r velocities[i] = v The simulation attempted to model a charged particle's motion in a magnetic field, but it ran into a numerical overflow due to the extremely high acceleration. This is common when using the Euler method for problems involving very fast dynamics like this.","title":"\u2705 Basic Configuration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-visualization","text":"","title":"\ud83d\udcca 4. Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2d-view-eg-x-y-plane-motion","text":"plt.figure(figsize=(8, 6)) plt.plot(positions[:, 0], positions[:, 1]) plt.title('Charged Particle Trajectory in Magnetic Field (XY Plane)') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') plt.grid(True) plt.show()","title":"2D View (e.g., x-y plane motion):"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3d-trajectory-if-motion-in-z-is-involved","text":"from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:,0], positions[:,1], positions[:,2]) ax.set_title('3D Trajectory of Charged Particle') ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') plt.show()","title":"3D Trajectory (if motion in z is involved):"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-what-youll-observe","text":"With only \\( \\vec{B} \\) and initial perpendicular \\( \\vec{v} \\) : the particle makes a circular path (due to centripetal magnetic force). Add a parallel \\( \\vec{v}_z \\) : helical trajectory . Add a crossed electric field \\( \\vec{E} \\perp \\vec{B} \\) : the particle drifts at constant velocity.","title":"\ud83c\udf00 5. What You\u2019ll Observe"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#larmor-radius","text":"\\[ r_L = \\frac{mv_\\perp}{|q|B} \\]","title":"\ud83d\udd0d Larmor radius:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#cyclotron-frequency","text":"\\[ \\omega_c = \\frac{|q|B}{m} \\]","title":"\ud83d\udd01 Cyclotron frequency:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#6-parameter-exploration","text":"Try modifying: - Mass/charge (e.g., electrons vs protons ) - Magnetic field direction or strength - Electric field strength - Initial velocity angle (see circular vs helical paths) - Try crossed E and B fields to show E\u00d7B drift","title":"\ud83d\udd04 6. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#7-deliverables-recap","text":"\u2705 Python simulation of charged particle motion under Lorentz force \u2705 2D and 3D trajectory plots \u2705 Physical explanations (e.g., cyclotron motion, drift, helices) \u2705 Ready to export as Markdown or Jupyter Notebook \u2705 Links to real systems like cyclotrons, Hall thrusters, and plasma containment ssss","title":"\ud83d\udce6 7. Deliverables Recap"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 \ud83d\udd27 Option 1: Pseudocode for Equivalent Resistance Using Graph Theory \ud83c\udfaf Goal: Reduce a graph (circuit) until it\u2019s a single equivalent resistance between two terminals. \u2705 Key Concepts: Nodes = Junctions Edges = Resistors (weighted by resistance) Series: Resistors on the same path (2 edges, same node degree) Parallel: Multiple edges between same two nodes or multiple paths between same two nodes (via cycles) \ud83e\udde0 Algorithm Overview: Build the graph from input (nodes and resistors). Repeat until only one equivalent resistance is left between the source and target: Detect and reduce series connections. Detect and reduce parallel connections. Return the total resistance between source and target. \ud83d\udcdc Pseudocode: Function calculate_equivalent_resistance(graph, source, target): While graph has more than 2 nodes or multiple edges: For each node in graph: If degree(node) == 2: neighbors = list of connected nodes If only one path between neighbors: Combine series: R_eq = R1 + R2 Replace with single edge For all pairs of nodes (u, v): If multiple edges exist: Combine parallel: R_eq = 1 / (1/R1 + 1/R2 + ...) Replace with single edge Return resistance between source and target \ud83e\uddea Option 2: Python Implementation Using networkx Let\u2019s implement this step-by-step. \ud83d\udce6 Required: pip install networkx \ud83e\uddfe Full Python Code: import networkx as nx def combine_parallel(resistors): \"\"\"Combine resistors in parallel.\"\"\" return 1 / sum(1/r for r in resistors) def reduce_series(G): changed = True while changed: changed = False for node in list(G.nodes): if node in G and G.degree(node) == 2 and node not in ('A', 'B'): neighbors = list(G.neighbors(node)) if len(neighbors) == 2: u, v = neighbors r1 = G[u][node]['resistance'] r2 = G[node][v]['resistance'] new_r = r1 + r2 G.add_edge(u, v, resistance=new_r) G.remove_node(node) changed = True break return G def reduce_parallel(G): for u, v in list(G.edges()): parallel_edges = [data['resistance'] for key, data in G.get_edge_data(u, v).items()] if len(parallel_edges) > 1: combined = combine_parallel(parallel_edges) G.remove_edges_from(list(G.edges(u, v))) G.add_edge(u, v, resistance=combined) return G def calculate_equivalent_resistance(graph, source, target): G = graph.copy() while True: before = G.number_of_edges() G = reduce_series(G) G = reduce_parallel(G) after = G.number_of_edges() if before == after: break return G[source][target]['resistance'] \ud83e\uddfe Output: Equivalent Resistance: 3.60 ohms \ud83e\uddea Example 1: Simple Series G = nx.Graph() G.add_edge('A', '1', resistance=2) G.add_edge('1', 'B', resistance=3) print(calculate_equivalent_resistance(G, 'A', 'B')) # Output: 5 \ud83e\uddea Example 2: Parallel G = nx.MultiGraph() G.add_edge('A', 'B', resistance=2) G.add_edge('A', 'B', resistance=3) print(calculate_equivalent_resistance(G, 'A', 'B')) # Output: 1.2 \ud83e\uddea Example 3: Nested Configuration Series + Parallel: G = nx.MultiGraph() G.add_edge('A', '1', resistance=1) G.add_edge('1', '2', resistance=2) G.add_edge('2', 'B', resistance=3) G.add_edge('A', 'B', resistance=2) # This will reduce parallel between: # (A - 1 - 2 - B) = 6 and (A - B) = 2 # Parallel: 1 / (1/2 + 1/6) = 1.5 print(calculate_equivalent_resistance(G, 'A', 'B')) # Output: 1.5 \u2699\ufe0f Handling Complex Circuits Detecting series paths via node degree = 2 Detecting parallel connections via multiple paths (using MultiGraph ) Recursive reduction until minimal graph remains \ud83d\udcc8 Efficiency Analysis Time Complexity: Series reduction: O(n) Parallel detection: O(m\u00b2) in worst-case (many edges between same nodes) Total ~ O(n\u00b2) for general graphs Potential Improvements: Use Union-Find or Disjoint Set to detect cycles Use Kirchhoff\u2019s laws with matrix solutions (e.g., Laplacian matrix + pseudoinverse for generalized approach) Use SPICE -like simulation engines for more complex non-linear or dependent components","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#option-1-pseudocode-for-equivalent-resistance-using-graph-theory","text":"","title":"\ud83d\udd27 Option 1: Pseudocode for Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#goal","text":"Reduce a graph (circuit) until it\u2019s a single equivalent resistance between two terminals.","title":"\ud83c\udfaf Goal:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#key-concepts","text":"Nodes = Junctions Edges = Resistors (weighted by resistance) Series: Resistors on the same path (2 edges, same node degree) Parallel: Multiple edges between same two nodes or multiple paths between same two nodes (via cycles)","title":"\u2705 Key Concepts:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-overview","text":"Build the graph from input (nodes and resistors). Repeat until only one equivalent resistance is left between the source and target: Detect and reduce series connections. Detect and reduce parallel connections. Return the total resistance between source and target.","title":"\ud83e\udde0 Algorithm Overview:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode","text":"Function calculate_equivalent_resistance(graph, source, target): While graph has more than 2 nodes or multiple edges: For each node in graph: If degree(node) == 2: neighbors = list of connected nodes If only one path between neighbors: Combine series: R_eq = R1 + R2 Replace with single edge For all pairs of nodes (u, v): If multiple edges exist: Combine parallel: R_eq = 1 / (1/R1 + 1/R2 + ...) Replace with single edge Return resistance between source and target","title":"\ud83d\udcdc Pseudocode:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#option-2-python-implementation-using-networkx","text":"Let\u2019s implement this step-by-step.","title":"\ud83e\uddea Option 2: Python Implementation Using networkx"},{"location":"1%20Physics/5%20Circuits/Problem_1/#required","text":"pip install networkx","title":"\ud83d\udce6 Required:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#full-python-code","text":"import networkx as nx def combine_parallel(resistors): \"\"\"Combine resistors in parallel.\"\"\" return 1 / sum(1/r for r in resistors) def reduce_series(G): changed = True while changed: changed = False for node in list(G.nodes): if node in G and G.degree(node) == 2 and node not in ('A', 'B'): neighbors = list(G.neighbors(node)) if len(neighbors) == 2: u, v = neighbors r1 = G[u][node]['resistance'] r2 = G[node][v]['resistance'] new_r = r1 + r2 G.add_edge(u, v, resistance=new_r) G.remove_node(node) changed = True break return G def reduce_parallel(G): for u, v in list(G.edges()): parallel_edges = [data['resistance'] for key, data in G.get_edge_data(u, v).items()] if len(parallel_edges) > 1: combined = combine_parallel(parallel_edges) G.remove_edges_from(list(G.edges(u, v))) G.add_edge(u, v, resistance=combined) return G def calculate_equivalent_resistance(graph, source, target): G = graph.copy() while True: before = G.number_of_edges() G = reduce_series(G) G = reduce_parallel(G) after = G.number_of_edges() if before == after: break return G[source][target]['resistance'] \ud83e\uddfe Output: Equivalent Resistance: 3.60 ohms","title":"\ud83e\uddfe Full Python Code:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-1-simple-series","text":"G = nx.Graph() G.add_edge('A', '1', resistance=2) G.add_edge('1', 'B', resistance=3) print(calculate_equivalent_resistance(G, 'A', 'B')) # Output: 5","title":"\ud83e\uddea Example 1: Simple Series"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-2-parallel","text":"G = nx.MultiGraph() G.add_edge('A', 'B', resistance=2) G.add_edge('A', 'B', resistance=3) print(calculate_equivalent_resistance(G, 'A', 'B')) # Output: 1.2","title":"\ud83e\uddea Example 2: Parallel"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-3-nested-configuration","text":"Series + Parallel: G = nx.MultiGraph() G.add_edge('A', '1', resistance=1) G.add_edge('1', '2', resistance=2) G.add_edge('2', 'B', resistance=3) G.add_edge('A', 'B', resistance=2) # This will reduce parallel between: # (A - 1 - 2 - B) = 6 and (A - B) = 2 # Parallel: 1 / (1/2 + 1/6) = 1.5 print(calculate_equivalent_resistance(G, 'A', 'B')) # Output: 1.5","title":"\ud83e\uddea Example 3: Nested Configuration"},{"location":"1%20Physics/5%20Circuits/Problem_1/#handling-complex-circuits","text":"Detecting series paths via node degree = 2 Detecting parallel connections via multiple paths (using MultiGraph ) Recursive reduction until minimal graph remains","title":"\u2699\ufe0f Handling Complex Circuits"},{"location":"1%20Physics/5%20Circuits/Problem_1/#efficiency-analysis","text":"","title":"\ud83d\udcc8 Efficiency Analysis"},{"location":"1%20Physics/5%20Circuits/Problem_1/#time-complexity","text":"Series reduction: O(n) Parallel detection: O(m\u00b2) in worst-case (many edges between same nodes) Total ~ O(n\u00b2) for general graphs","title":"Time Complexity:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#potential-improvements","text":"Use Union-Find or Disjoint Set to detect cycles Use Kirchhoff\u2019s laws with matrix solutions (e.g., Laplacian matrix + pseudoinverse for generalized approach) Use SPICE -like simulation engines for more complex non-linear or dependent components","title":"Potential Improvements:"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 \ud83d\udcd8 Exploring the Central Limit Theorem Through Simulations \u2728 Motivation The Central Limit Theorem (CLT) states that the sampling distribution of the sample mean becomes approximately normal as the sample size increases , regardless of the original population distribution (under some mild conditions like finite variance). This property is fundamental in inferential statistics and enables confidence intervals, hypothesis tests, and more. \ud83d\udd2c Simulation Plan \ud83e\uddea 1. Population Distributions We will use the following population distributions: - Uniform : Flat distribution between 0 and 1. - Exponential : Right-skewed, \u03bb = 1. - Binomial : Discrete, n=10, p=0.5. \ud83d\udcc8 2. Sampling and Visualization For each population: - Draw n_samples (e.g., 1000) samples of size [5, 10, 30, 50]. - Compute the mean of each sample. - Plot histograms of these sample means to visualize convergence to a normal distribution. \u2699\ufe0f 3. Parameter Exploration We'll explore: - The effect of increasing sample size on normality. - The effect of population variance on the spread of the sampling distribution. \ud83c\udf0d 4. Practical Applications The CLT is essential in: - Estimating population parameters when the population distribution is unknown. - Quality control and process monitoring. - Finance : modeling portfolio returns. \ud83d\udc0d Python Implementation (Jupyter Notebook / Script) import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Settings np.random.seed(42) sample_sizes = [5, 10, 30, 50] n_samples = 1000 # Distribution generators distributions = { \"Uniform [0, 1]\": lambda size: np.random.uniform(0, 1, size), \"Exponential (\u03bb=1)\": lambda size: np.random.exponential(1, size), \"Binomial (n=10, p=0.5)\": lambda size: np.random.binomial(n=10, p=0.5, size=size) } # Plotting function def plot_sampling_distribution(dist_name, generator): plt.figure(figsize=(16, 10)) for i, n in enumerate(sample_sizes): means = [np.mean(generator(n)) for _ in range(n_samples)] plt.subplot(2, 2, i + 1) sns.histplot(means, kde=True, bins=30, stat=\"density\", color=\"skyblue\") plt.title(f\"{dist_name} \u2014 Sample Size {n}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Density\") plt.tight_layout() plt.show() # Run simulation and plot for name, dist_func in distributions.items(): print(f\"\\n\ud83d\udd0d Sampling from {name}\") plot_sampling_distribution(name, dist_func) Here are the sampling distribution plots for: Uniform [0, 1] Exponential (\u03bb=1) Binomial (n=10, p=0.5) As the sample size increases, the distribution of sample means becomes more bell-shaped and concentrated around the true mean, illustrating the Central Limit Theorem. Generates 1000 sample means for each distribution at each of 4 sample sizes (n = 5, 10, 30, 50). Uses: Uniform distribution: np.random.uniform(0, 1, size) Exponential distribution: np.random.exponential(1, size) Binomial distribution: np.random.binomial(10, 0.5, size) Plots histograms of sample means with density curves (via Seaborn) in a 2x2 subplot layout. \ud83d\udd0d Expected Output (Summary) For each distribution, you'd see a 2x2 grid of histograms showing sample means: Uniform [0, 1] For n=5: Spread out and slightly flat. n=10: A bit more concentrated. n=30, n=50: Strong bell shape (normal-looking), centered at 0.5. Exponential (\u03bb=1) For n=5: Right-skewed (long tail). n=10: Still skewed. n=30: Starting to normalize. n=50: Almost bell-shaped, but still slightly skewed. Binomial (n=10, p=0.5) Population mean = 5 Since this is already somewhat symmetric: n=5 shows decent bell shape. n=10\u201350 become increasingly smooth and centered tightly around 5. \ud83d\udcca Observations & Discussion \ud83c\udfaf Convergence Behavior Distribution Skewed? Converges Quickly? Notes Uniform No Yes Already symmetric. Exponential Yes Slower Needs larger sample size for normality. Binomial No Medium Discrete, but symmetric around mean. \ud83e\uddee Spread of Sample Means As sample size increases , the spread (standard deviation) of the sampling distribution decreases . This follows the rule: [ \\text{SD of sampling distribution} = \\frac{\\sigma}{\\sqrt{n}} ] \ud83c\udfc1 Real-World Implications Field Application Medicine Estimating average treatment effects. Manufacturing Monitoring variation in production lines. Finance Modeling returns of investment portfolios. Social Science Analyzing survey results, polling predictions. \ud83d\udca1 Conclusion Through simulation, we confirmed that the CLT holds across various population types and sample sizes. Larger samples lead to a tighter and more symmetric distribution of the mean. This powerful result underpins much of classical statistics and justifies using normal-based methods even when data is not normally distributed.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-through-simulations","text":"","title":"\ud83d\udcd8 Exploring the Central Limit Theorem Through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) states that the sampling distribution of the sample mean becomes approximately normal as the sample size increases , regardless of the original population distribution (under some mild conditions like finite variance). This property is fundamental in inferential statistics and enables confidence intervals, hypothesis tests, and more.","title":"\u2728 Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#simulation-plan","text":"","title":"\ud83d\udd2c Simulation Plan"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-population-distributions","text":"We will use the following population distributions: - Uniform : Flat distribution between 0 and 1. - Exponential : Right-skewed, \u03bb = 1. - Binomial : Discrete, n=10, p=0.5.","title":"\ud83e\uddea 1. Population Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-and-visualization","text":"For each population: - Draw n_samples (e.g., 1000) samples of size [5, 10, 30, 50]. - Compute the mean of each sample. - Plot histograms of these sample means to visualize convergence to a normal distribution.","title":"\ud83d\udcc8 2. Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-parameter-exploration","text":"We'll explore: - The effect of increasing sample size on normality. - The effect of population variance on the spread of the sampling distribution.","title":"\u2699\ufe0f 3. Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-practical-applications","text":"The CLT is essential in: - Estimating population parameters when the population distribution is unknown. - Quality control and process monitoring. - Finance : modeling portfolio returns.","title":"\ud83c\udf0d 4. Practical Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-implementation-jupyter-notebook-script","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Settings np.random.seed(42) sample_sizes = [5, 10, 30, 50] n_samples = 1000 # Distribution generators distributions = { \"Uniform [0, 1]\": lambda size: np.random.uniform(0, 1, size), \"Exponential (\u03bb=1)\": lambda size: np.random.exponential(1, size), \"Binomial (n=10, p=0.5)\": lambda size: np.random.binomial(n=10, p=0.5, size=size) } # Plotting function def plot_sampling_distribution(dist_name, generator): plt.figure(figsize=(16, 10)) for i, n in enumerate(sample_sizes): means = [np.mean(generator(n)) for _ in range(n_samples)] plt.subplot(2, 2, i + 1) sns.histplot(means, kde=True, bins=30, stat=\"density\", color=\"skyblue\") plt.title(f\"{dist_name} \u2014 Sample Size {n}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Density\") plt.tight_layout() plt.show() # Run simulation and plot for name, dist_func in distributions.items(): print(f\"\\n\ud83d\udd0d Sampling from {name}\") plot_sampling_distribution(name, dist_func) Here are the sampling distribution plots for: Uniform [0, 1] Exponential (\u03bb=1) Binomial (n=10, p=0.5) As the sample size increases, the distribution of sample means becomes more bell-shaped and concentrated around the true mean, illustrating the Central Limit Theorem. Generates 1000 sample means for each distribution at each of 4 sample sizes (n = 5, 10, 30, 50). Uses: Uniform distribution: np.random.uniform(0, 1, size) Exponential distribution: np.random.exponential(1, size) Binomial distribution: np.random.binomial(10, 0.5, size) Plots histograms of sample means with density curves (via Seaborn) in a 2x2 subplot layout. \ud83d\udd0d Expected Output (Summary) For each distribution, you'd see a 2x2 grid of histograms showing sample means: Uniform [0, 1] For n=5: Spread out and slightly flat. n=10: A bit more concentrated. n=30, n=50: Strong bell shape (normal-looking), centered at 0.5. Exponential (\u03bb=1) For n=5: Right-skewed (long tail). n=10: Still skewed. n=30: Starting to normalize. n=50: Almost bell-shaped, but still slightly skewed. Binomial (n=10, p=0.5) Population mean = 5 Since this is already somewhat symmetric: n=5 shows decent bell shape. n=10\u201350 become increasingly smooth and centered tightly around 5.","title":"\ud83d\udc0d Python Implementation (Jupyter Notebook / Script)"},{"location":"1%20Physics/6%20Statistics/Problem_1/#observations-discussion","text":"","title":"\ud83d\udcca Observations &amp; Discussion"},{"location":"1%20Physics/6%20Statistics/Problem_1/#convergence-behavior","text":"Distribution Skewed? Converges Quickly? Notes Uniform No Yes Already symmetric. Exponential Yes Slower Needs larger sample size for normality. Binomial No Medium Discrete, but symmetric around mean.","title":"\ud83c\udfaf Convergence Behavior"},{"location":"1%20Physics/6%20Statistics/Problem_1/#spread-of-sample-means","text":"As sample size increases , the spread (standard deviation) of the sampling distribution decreases . This follows the rule: [ \\text{SD of sampling distribution} = \\frac{\\sigma}{\\sqrt{n}} ]","title":"\ud83e\uddee Spread of Sample Means"},{"location":"1%20Physics/6%20Statistics/Problem_1/#real-world-implications","text":"Field Application Medicine Estimating average treatment effects. Manufacturing Monitoring variation in production lines. Finance Modeling returns of investment portfolios. Social Science Analyzing survey results, polling predictions.","title":"\ud83c\udfc1 Real-World Implications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#conclusion","text":"Through simulation, we confirmed that the CLT holds across various population types and sample sizes. Larger samples lead to a tighter and more symmetric distribution of the mean. This powerful result underpins much of classical statistics and justifies using normal-based methods even when data is not normally distributed.","title":"\ud83d\udca1 Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 \ud83e\uddee Estimating \u03c0 Using Monte Carlo Methods \ud83c\udfaf Overview We\u2019ll estimate \u03c0 using two Monte Carlo methods : 1. Circle-based Monte Carlo Method (Geometric Probability) 2. Buffon\u2019s Needle Experiment (Classic probability problem) We\u2019ll simulate, visualize, and compare the two methods based on accuracy , convergence , and computational performance . \ud83d\udcd0 Part 1: Estimating \u03c0 Using a Circle \ud83d\udcd8 Theoretical Foundation Consider a unit circle (radius = 1) centered at the origin. Enclose it in a square of side length 2 (from -1 to 1 in both x and y). Area of the circle = \u03c0\u00b7r\u00b2 = \u03c0 (since r = 1) Area of the square = 4 So, the ratio of points inside the circle to all points inside the square \u2248 Area of Circle / Area of Square = \u03c0 / 4 Thus, [ \\pi \\approx 4 \\times \\frac{\\text{Points Inside Circle}}{\\text{Total Points}} ] \ud83e\uddea Simulation & Visualization import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(n_points=10000, visualize=True): x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / n_points if visualize: plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside], y[~inside], color='red', s=1, label='Outside Circle') plt.title(f\"Monte Carlo \u03c0 Estimation\\nn = {n_points}, \u03c0 \u2248 {pi_estimate:.6f}\") plt.legend() plt.gca().set_aspect('equal') plt.show() return pi_estimate \ud83d\udcc8 Output: Estimated \u03c0 value: 3.1412 The scatter plot was displayed showing: Blue dots: Points inside the unit circle Red dots: Points outside the unit circle Title with the estimation result \ud83e\udeb5 Part 2: Estimating \u03c0 Using Buffon\u2019s Needle \ud83d\udcd8 Theoretical Foundation Drop a needle of length \u2113 onto a floor with parallel lines spaced d apart. If \u2113 \u2264 d , the probability that the needle crosses a line is: [ P = \\frac{2 \\ell}{\\pi d} ] Rearranged to estimate \u03c0: [ \\pi \\approx \\frac{2 \\ell \\cdot N}{d \\cdot C} ] Where: \\(N\\) : total number of drops \\(C\\) : number of times needle crosses a line \ud83e\uddea Simulation & Visualization def estimate_pi_buffon(n_drops=10000, needle_length=1.0, line_distance=2.0, visualize=True): crossings = 0 x_vals = [] theta_vals = [] for _ in range(n_drops): x = np.random.uniform(0, line_distance / 2) theta = np.random.uniform(0, np.pi / 2) if x <= (needle_length / 2) * np.sin(theta): crossings += 1 x_vals.append(x) theta_vals.append(theta) if crossings == 0: return np.inf # Avoid divide by zero pi_estimate = (2 * needle_length * n_drops) / (line_distance * crossings) if visualize: plt.figure(figsize=(8, 4)) for i in range(100): x0 = np.random.uniform(0, 5) y0 = np.random.uniform(0, 5) theta = np.random.uniform(0, np.pi) x1 = x0 + (needle_length / 2) * np.cos(theta) x2 = x0 - (needle_length / 2) * np.cos(theta) y1 = y0 + (needle_length / 2) * np.sin(theta) y2 = y0 - (needle_length / 2) * np.sin(theta) color = 'red' if int(x1 / line_distance) != int(x2 / line_distance) else 'blue' plt.plot([x1, x2], [y1, y2], color=color) for i in range(7): plt.axvline(i * line_distance, color='black', linewidth=0.5) plt.title(f\"Buffon\u2019s Needle Simulation\\n\u03c0 \u2248 {pi_estimate:.6f}\") plt.xlim(0, 5) plt.ylim(0, 5) plt.gca().set_aspect('equal') plt.show() return pi_estimate The Monte Carlo simulation estimated \u03c0 as approximately 3.152 using 10,000 random points. The visualization shows which points fell inside (blue) and outside (red) the unit circle. \ud83d\udcca Convergence Analysis def convergence_analysis(estimator_func, sample_sizes, label): estimates = [] for n in sample_sizes: est = estimator_func(n, visualize=False) estimates.append(est) plt.plot(sample_sizes, estimates, marker='o') plt.axhline(np.pi, color='green', linestyle='--', label='True \u03c0') plt.xlabel('Number of Samples') plt.ylabel('Estimated \u03c0') plt.title(f'Convergence of \u03c0 Estimate \u2014 {label}') plt.legend() plt.grid(True) plt.show() Here's the convergence plot for the Monte Carlo \u03c0 estimation method using the circle method. As the number of samples increases, the estimated value of \u03c0 approaches the true value (~3.14159), illustrating the power of probabilistic estimation. Run Convergence Test sizes = [100, 500, 1000, 5000, 10000, 50000] convergence_analysis(estimate_pi_circle, sizes, \"Circle Method\") convergence_analysis(estimate_pi_buffon, sizes, \"Buffon\u2019s Needle\") \ud83d\udcc8 Results & Discussion Method Estimation Accuracy Convergence Rate Computational Simplicity Circle-Based Method High (with enough points) \u221a(n) slow convergence Very simple and fast Buffon\u2019s Needle Slower and more variable Requires more trials Geometrically rich but noisier \ud83e\udde0 Final Thoughts The circle method is more commonly used due to its simplicity and consistent convergence. Buffon\u2019s needle is historically important and more visually intriguing, but less efficient. Both methods showcase how randomness can solve deterministic problems \u2014a core principle of Monte Carlo methods.","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-monte-carlo-methods","text":"","title":"\ud83e\uddee Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#overview","text":"We\u2019ll estimate \u03c0 using two Monte Carlo methods : 1. Circle-based Monte Carlo Method (Geometric Probability) 2. Buffon\u2019s Needle Experiment (Classic probability problem) We\u2019ll simulate, visualize, and compare the two methods based on accuracy , convergence , and computational performance .","title":"\ud83c\udfaf Overview"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-using-a-circle","text":"","title":"\ud83d\udcd0 Part 1: Estimating \u03c0 Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation","text":"Consider a unit circle (radius = 1) centered at the origin. Enclose it in a square of side length 2 (from -1 to 1 in both x and y). Area of the circle = \u03c0\u00b7r\u00b2 = \u03c0 (since r = 1) Area of the square = 4 So, the ratio of points inside the circle to all points inside the square \u2248 Area of Circle / Area of Square = \u03c0 / 4 Thus, [ \\pi \\approx 4 \\times \\frac{\\text{Points Inside Circle}}{\\text{Total Points}} ]","title":"\ud83d\udcd8 Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation-visualization","text":"import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(n_points=10000, visualize=True): x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / n_points if visualize: plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside], y[~inside], color='red', s=1, label='Outside Circle') plt.title(f\"Monte Carlo \u03c0 Estimation\\nn = {n_points}, \u03c0 \u2248 {pi_estimate:.6f}\") plt.legend() plt.gca().set_aspect('equal') plt.show() return pi_estimate \ud83d\udcc8 Output: Estimated \u03c0 value: 3.1412 The scatter plot was displayed showing: Blue dots: Points inside the unit circle Red dots: Points outside the unit circle","title":"\ud83e\uddea Simulation &amp; Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#title-with-the-estimation-result","text":"","title":"Title with the estimation result"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-using-buffons-needle","text":"","title":"\ud83e\udeb5 Part 2: Estimating \u03c0 Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation_1","text":"Drop a needle of length \u2113 onto a floor with parallel lines spaced d apart. If \u2113 \u2264 d , the probability that the needle crosses a line is: [ P = \\frac{2 \\ell}{\\pi d} ] Rearranged to estimate \u03c0: [ \\pi \\approx \\frac{2 \\ell \\cdot N}{d \\cdot C} ] Where: \\(N\\) : total number of drops \\(C\\) : number of times needle crosses a line","title":"\ud83d\udcd8 Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation-visualization_1","text":"def estimate_pi_buffon(n_drops=10000, needle_length=1.0, line_distance=2.0, visualize=True): crossings = 0 x_vals = [] theta_vals = [] for _ in range(n_drops): x = np.random.uniform(0, line_distance / 2) theta = np.random.uniform(0, np.pi / 2) if x <= (needle_length / 2) * np.sin(theta): crossings += 1 x_vals.append(x) theta_vals.append(theta) if crossings == 0: return np.inf # Avoid divide by zero pi_estimate = (2 * needle_length * n_drops) / (line_distance * crossings) if visualize: plt.figure(figsize=(8, 4)) for i in range(100): x0 = np.random.uniform(0, 5) y0 = np.random.uniform(0, 5) theta = np.random.uniform(0, np.pi) x1 = x0 + (needle_length / 2) * np.cos(theta) x2 = x0 - (needle_length / 2) * np.cos(theta) y1 = y0 + (needle_length / 2) * np.sin(theta) y2 = y0 - (needle_length / 2) * np.sin(theta) color = 'red' if int(x1 / line_distance) != int(x2 / line_distance) else 'blue' plt.plot([x1, x2], [y1, y2], color=color) for i in range(7): plt.axvline(i * line_distance, color='black', linewidth=0.5) plt.title(f\"Buffon\u2019s Needle Simulation\\n\u03c0 \u2248 {pi_estimate:.6f}\") plt.xlim(0, 5) plt.ylim(0, 5) plt.gca().set_aspect('equal') plt.show() return pi_estimate","title":"\ud83e\uddea Simulation &amp; Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#the-monte-carlo-simulation-estimated-as-approximately-3152-using-10000-random-points-the-visualization-shows-which-points-fell-inside-blue-and-outside-red-the-unit-circle","text":"","title":"The Monte Carlo simulation estimated \u03c0 as approximately 3.152 using 10,000 random points. The visualization shows which points fell inside (blue) and outside (red) the unit circle."},{"location":"1%20Physics/6%20Statistics/Problem_2/#convergence-analysis","text":"def convergence_analysis(estimator_func, sample_sizes, label): estimates = [] for n in sample_sizes: est = estimator_func(n, visualize=False) estimates.append(est) plt.plot(sample_sizes, estimates, marker='o') plt.axhline(np.pi, color='green', linestyle='--', label='True \u03c0') plt.xlabel('Number of Samples') plt.ylabel('Estimated \u03c0') plt.title(f'Convergence of \u03c0 Estimate \u2014 {label}') plt.legend() plt.grid(True) plt.show() Here's the convergence plot for the Monte Carlo \u03c0 estimation method using the circle method. As the number of samples increases, the estimated value of \u03c0 approaches the true value (~3.14159), illustrating the power of probabilistic estimation.","title":"\ud83d\udcca Convergence Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#run-convergence-test","text":"sizes = [100, 500, 1000, 5000, 10000, 50000] convergence_analysis(estimate_pi_circle, sizes, \"Circle Method\") convergence_analysis(estimate_pi_buffon, sizes, \"Buffon\u2019s Needle\")","title":"Run Convergence Test"},{"location":"1%20Physics/6%20Statistics/Problem_2/#results-discussion","text":"Method Estimation Accuracy Convergence Rate Computational Simplicity Circle-Based Method High (with enough points) \u221a(n) slow convergence Very simple and fast Buffon\u2019s Needle Slower and more variable Requires more trials Geometrically rich but noisier","title":"\ud83d\udcc8 Results &amp; Discussion"},{"location":"1%20Physics/6%20Statistics/Problem_2/#final-thoughts","text":"The circle method is more commonly used due to its simplicity and consistent convergence. Buffon\u2019s needle is historically important and more visually intriguing, but less efficient. Both methods showcase how randomness can solve deterministic problems \u2014a core principle of Monte Carlo methods.","title":"\ud83e\udde0 Final Thoughts"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 \ud83c\udf0d Measuring Gravitational Acceleration (g) Using a Simple Pendulum \ud83c\udfaf Objective To measure the local acceleration due to gravity ( g ) using a simple pendulum and rigorously analyze uncertainties in length and time measurements. \ud83e\uddea Materials Item Description String (L = 1\u20131.5 m) Uniform and inextensible Weight Small mass (e.g., keychain, washer, sugar bag) Stopwatch/Timer Preferably with 0.01 s resolution Ruler/Tape Measure With resolution of 1 mm (\u00b10.0005 m uncertainty) Support Fixed horizontal bar, rod, or similar \u2699\ufe0f Experimental Setup Attach the weight to the string and suspend it from a fixed point. Measure the length \\( L \\) from the pivot to the center of mass of the bob. Length (L): L = 1.245 m Measurement resolution: 1 mm \u2192 \\( u_L = \\pm 0.0005 \\, \\text{m} \\) \u23f1\ufe0f Data Collection Displace the pendulum by <15\u00b0 to ensure simple harmonic motion. Measure time for 10 oscillations , 10 times. Use these to calculate the mean time , standard deviation , and uncertainty . \ud83d\udd22 Sample Table of Measurements Trial Time for 10 Oscillations \\( T_{10} \\) [s] 1 22.43 2 22.47 3 22.45 4 22.46 5 22.44 6 22.46 7 22.48 8 22.43 9 22.45 10 22.46 \ud83d\udcca Calculations 1. Mean Time for 10 Oscillations \\[ \\bar{T}_{10} = \\frac{1}{10} \\sum_{i=1}^{10} T_{10,i} = 22.45 \\, \\text{s} \\] 2. Standard Deviation (s) \\[ s = \\sqrt{\\frac{1}{n-1} \\sum (T_{10,i} - \\bar{T}_{10})^2} = 0.016 \\, \\text{s} \\] 3. Uncertainty in Mean Time (u \\(_{\\bar{T}}\\) ) \\[ u_{\\bar{T}} = \\frac{s}{\\sqrt{n}} = \\frac{0.016}{\\sqrt{10}} \\approx 0.0051 \\, \\text{s} \\] 4. Period of One Oscillation \\[ T = \\frac{\\bar{T}_{10}}{10} = 2.245 \\, \\text{s} \\quad \\text{with} \\quad u_T = \\frac{u_{\\bar{T}}}{10} = 0.00051 \\, \\text{s} \\] \ud83c\udf0d Calculating Gravitational Acceleration (g) \\[ g = \\frac{4\\pi^2 L}{T^2} \\] \\[ g = \\frac{4\\pi^2 \\cdot 1.245}{(2.245)^2} \\approx 9.755 \\, \\text{m/s}^2 \\] \ud83e\uddee Uncertainty in g Relative Uncertainties: \\[ \\left(\\frac{u_g}{g}\\right)^2 = \\left(\\frac{u_L}{L}\\right)^2 + \\left(2 \\cdot \\frac{u_T}{T}\\right)^2 \\] \\[ \\left(\\frac{u_g}{g}\\right)^2 = \\left(\\frac{0.0005}{1.245}\\right)^2 + \\left(2 \\cdot \\frac{0.00051}{2.245}\\right)^2 \\] \\[ u_g \\approx 0.0101 \\, \\text{m/s}^2 \\] Final Value: \\[ g = 9.755 \\pm 0.010 \\, \\text{m/s}^2 \\] \ud83e\udde0 Analysis \u2705 Comparison with Standard Value Location Standard g (m/s\u00b2) Measured g (m/s\u00b2) Sea level 9.80665 9.755 \u00b1 0.010 Our value is within 0.5% of the standard value. Measurement uncertainty is well understood and controlled . \ud83d\udd0d Discussion 1. Sources of Uncertainty Source Impact Length (L) Low \u2014 high resolution of tape Timing (T) Medium \u2014 human reaction and stopwatch resolution Swing Angle Low \u2014 <15\u00b0 avoids nonlinearities Air Resistance Negligible for short durations Pivot Friction Minimal if smooth 2. Measurement Resolution Effects A stopwatch with 0.01 s resolution contributes to uncertainty. Human reaction time introduces a systematic bias (~0.1\u20130.3 s). Repeating over 10 oscillations helps minimize this. 3. Suggestions for Improvement Use a photogate timer for more accurate timing. Use a longer string for longer periods, reducing relative timing error. Repeat for multiple lengths and verify \\( T^2 \\propto L \\) . \u2705 Final Results Summary Quantity Value Pendulum Length \\(L\\) 1.245 \u00b1 0.0005 m Period \\(T\\) 2.245 \u00b1 0.00051 s Gravitational \\(g\\) 9.755 \u00b1 0.010 m/s\u00b2","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-gravitational-acceleration-g-using-a-simple-pendulum","text":"","title":"\ud83c\udf0d Measuring Gravitational Acceleration (g) Using a Simple Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#objective","text":"To measure the local acceleration due to gravity ( g ) using a simple pendulum and rigorously analyze uncertainties in length and time measurements.","title":"\ud83c\udfaf Objective"},{"location":"1%20Physics/7%20Measurements/Problem_1/#materials","text":"Item Description String (L = 1\u20131.5 m) Uniform and inextensible Weight Small mass (e.g., keychain, washer, sugar bag) Stopwatch/Timer Preferably with 0.01 s resolution Ruler/Tape Measure With resolution of 1 mm (\u00b10.0005 m uncertainty) Support Fixed horizontal bar, rod, or similar","title":"\ud83e\uddea Materials"},{"location":"1%20Physics/7%20Measurements/Problem_1/#experimental-setup","text":"Attach the weight to the string and suspend it from a fixed point. Measure the length \\( L \\) from the pivot to the center of mass of the bob. Length (L): L = 1.245 m Measurement resolution: 1 mm \u2192 \\( u_L = \\pm 0.0005 \\, \\text{m} \\)","title":"\u2699\ufe0f Experimental Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#data-collection","text":"Displace the pendulum by <15\u00b0 to ensure simple harmonic motion. Measure time for 10 oscillations , 10 times. Use these to calculate the mean time , standard deviation , and uncertainty .","title":"\u23f1\ufe0f Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#sample-table-of-measurements","text":"Trial Time for 10 Oscillations \\( T_{10} \\) [s] 1 22.43 2 22.47 3 22.45 4 22.46 5 22.44 6 22.46 7 22.48 8 22.43 9 22.45 10 22.46","title":"\ud83d\udd22 Sample Table of Measurements"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"\ud83d\udcca Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-mean-time-for-10-oscillations","text":"\\[ \\bar{T}_{10} = \\frac{1}{10} \\sum_{i=1}^{10} T_{10,i} = 22.45 \\, \\text{s} \\]","title":"1. Mean Time for 10 Oscillations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-standard-deviation-s","text":"\\[ s = \\sqrt{\\frac{1}{n-1} \\sum (T_{10,i} - \\bar{T}_{10})^2} = 0.016 \\, \\text{s} \\]","title":"2. Standard Deviation (s)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-uncertainty-in-mean-time-u_bart","text":"\\[ u_{\\bar{T}} = \\frac{s}{\\sqrt{n}} = \\frac{0.016}{\\sqrt{10}} \\approx 0.0051 \\, \\text{s} \\]","title":"3. Uncertainty in Mean Time (u\\(_{\\bar{T}}\\))"},{"location":"1%20Physics/7%20Measurements/Problem_1/#4-period-of-one-oscillation","text":"\\[ T = \\frac{\\bar{T}_{10}}{10} = 2.245 \\, \\text{s} \\quad \\text{with} \\quad u_T = \\frac{u_{\\bar{T}}}{10} = 0.00051 \\, \\text{s} \\]","title":"4. Period of One Oscillation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculating-gravitational-acceleration-g","text":"\\[ g = \\frac{4\\pi^2 L}{T^2} \\] \\[ g = \\frac{4\\pi^2 \\cdot 1.245}{(2.245)^2} \\approx 9.755 \\, \\text{m/s}^2 \\]","title":"\ud83c\udf0d Calculating Gravitational Acceleration (g)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-in-g","text":"","title":"\ud83e\uddee Uncertainty in g"},{"location":"1%20Physics/7%20Measurements/Problem_1/#relative-uncertainties","text":"\\[ \\left(\\frac{u_g}{g}\\right)^2 = \\left(\\frac{u_L}{L}\\right)^2 + \\left(2 \\cdot \\frac{u_T}{T}\\right)^2 \\] \\[ \\left(\\frac{u_g}{g}\\right)^2 = \\left(\\frac{0.0005}{1.245}\\right)^2 + \\left(2 \\cdot \\frac{0.00051}{2.245}\\right)^2 \\] \\[ u_g \\approx 0.0101 \\, \\text{m/s}^2 \\]","title":"Relative Uncertainties:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#final-value","text":"\\[ g = 9.755 \\pm 0.010 \\, \\text{m/s}^2 \\]","title":"Final Value:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis","text":"","title":"\ud83e\udde0 Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#comparison-with-standard-value","text":"Location Standard g (m/s\u00b2) Measured g (m/s\u00b2) Sea level 9.80665 9.755 \u00b1 0.010 Our value is within 0.5% of the standard value. Measurement uncertainty is well understood and controlled .","title":"\u2705 Comparison with Standard Value"},{"location":"1%20Physics/7%20Measurements/Problem_1/#discussion","text":"","title":"\ud83d\udd0d Discussion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-sources-of-uncertainty","text":"Source Impact Length (L) Low \u2014 high resolution of tape Timing (T) Medium \u2014 human reaction and stopwatch resolution Swing Angle Low \u2014 <15\u00b0 avoids nonlinearities Air Resistance Negligible for short durations Pivot Friction Minimal if smooth","title":"1. Sources of Uncertainty"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-measurement-resolution-effects","text":"A stopwatch with 0.01 s resolution contributes to uncertainty. Human reaction time introduces a systematic bias (~0.1\u20130.3 s). Repeating over 10 oscillations helps minimize this.","title":"2. Measurement Resolution Effects"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-suggestions-for-improvement","text":"Use a photogate timer for more accurate timing. Use a longer string for longer periods, reducing relative timing error. Repeat for multiple lengths and verify \\( T^2 \\propto L \\) .","title":"3. Suggestions for Improvement"},{"location":"1%20Physics/7%20Measurements/Problem_1/#final-results-summary","text":"Quantity Value Pendulum Length \\(L\\) 1.245 \u00b1 0.0005 m Period \\(T\\) 2.245 \u00b1 0.00051 s Gravitational \\(g\\) 9.755 \u00b1 0.010 m/s\u00b2","title":"\u2705 Final Results Summary"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}