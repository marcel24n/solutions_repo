{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 \ud83d\udcd8 1. Theoretical Foundation We start with the equations of projectile motion , assuming: - No air resistance - Launched from ground level - Constant gravitational acceleration g = 9.81 m/s\u00b2 \u25b6\ufe0f Basic Kinematic Equations: Let a projectile be launched with: - Initial velocity: \\( v_0 \\) - Angle of projection: \\( \\theta \\) - From: \\( y_0 = 0 \\) Split into horizontal and vertical components: - \\( v_{x} = v_0 \\cos\\theta \\) - \\( v_{y} = v_0 \\sin\\theta \\) Time of flight (when projectile returns to ground): \\[ t_{\\text{flight}} = \\frac{2v_0 \\sin\\theta}{g} \\] Horizontal Range: \\[ R = v_{x} \\cdot t_{\\text{flight}} = v_0 \\cos\\theta \\cdot \\left(\\frac{2v_0 \\sin\\theta}{g}\\right) \\] \\[ \\boxed{R = \\frac{v_0^2 \\sin(2\\theta)}{g}} \\] This shows the range depends on \\( \\sin(2\\theta) \\) \u2014 maximum at \\( \\theta = 45^\\circ \\) . \ud83d\udcc8 2. Analysis of the Range \ud83d\udccc Insights: Maximum range occurs at \\( \\theta = 45^\\circ \\) For angles \\( \\theta \\) and \\( 90^\\circ - \\theta \\) , the range is the same The range increases with initial velocity \\( v_0 \\) , and decreases with gravity \\( g \\) \ud83d\udd27 3. Practical Applications This simple model works great when: - You launch from a flat surface - No air resistance But real life is messy! Consider: - Launch from a height (e.g., cliff or hill) - Uneven ground or slopes - Air drag (which heavily alters the trajectory) - Wind forces or spin (like a baseball or golf ball) In those cases, we\u2019d modify our model with: - Drag force: \\( F_d = -kv \\) - Numerical simulation (Euler or Runge-Kutta) \ud83d\udcbb 4. Implementation (Python Script) Let\u2019s implement a simulation and plot Range vs Angle for different velocities. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravity (m/s^2) angles = np.radians(np.linspace(0, 90, 500)) # angles in radians # Initial velocities to compare velocities = [10, 20, 30] # m/s plt.figure(figsize=(10, 6)) for v0 in velocities: ranges = (v0 ** 2) * np.sin(2 * angles) / g plt.plot(np.degrees(angles), ranges, label=f'v\u2080 = {v0} m/s') plt.title('Projectile Range vs Angle of Projection') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.show()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"We start with the equations of projectile motion , assuming: - No air resistance - Launched from ground level - Constant gravitational acceleration g = 9.81 m/s\u00b2","title":"\ud83d\udcd8 1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#basic-kinematic-equations","text":"Let a projectile be launched with: - Initial velocity: \\( v_0 \\) - Angle of projection: \\( \\theta \\) - From: \\( y_0 = 0 \\) Split into horizontal and vertical components: - \\( v_{x} = v_0 \\cos\\theta \\) - \\( v_{y} = v_0 \\sin\\theta \\)","title":"\u25b6\ufe0f Basic Kinematic Equations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight-when-projectile-returns-to-ground","text":"\\[ t_{\\text{flight}} = \\frac{2v_0 \\sin\\theta}{g} \\]","title":"Time of flight (when projectile returns to ground):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-range","text":"\\[ R = v_{x} \\cdot t_{\\text{flight}} = v_0 \\cos\\theta \\cdot \\left(\\frac{2v_0 \\sin\\theta}{g}\\right) \\] \\[ \\boxed{R = \\frac{v_0^2 \\sin(2\\theta)}{g}} \\] This shows the range depends on \\( \\sin(2\\theta) \\) \u2014 maximum at \\( \\theta = 45^\\circ \\) .","title":"Horizontal Range:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"\ud83d\udcc8 2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#insights","text":"Maximum range occurs at \\( \\theta = 45^\\circ \\) For angles \\( \\theta \\) and \\( 90^\\circ - \\theta \\) , the range is the same The range increases with initial velocity \\( v_0 \\) , and decreases with gravity \\( g \\)","title":"\ud83d\udccc Insights:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"This simple model works great when: - You launch from a flat surface - No air resistance But real life is messy! Consider: - Launch from a height (e.g., cliff or hill) - Uneven ground or slopes - Air drag (which heavily alters the trajectory) - Wind forces or spin (like a baseball or golf ball) In those cases, we\u2019d modify our model with: - Drag force: \\( F_d = -kv \\) - Numerical simulation (Euler or Runge-Kutta)","title":"\ud83d\udd27 3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-script","text":"Let\u2019s implement a simulation and plot Range vs Angle for different velocities. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravity (m/s^2) angles = np.radians(np.linspace(0, 90, 500)) # angles in radians # Initial velocities to compare velocities = [10, 20, 30] # m/s plt.figure(figsize=(10, 6)) for v0 in velocities: ranges = (v0 ** 2) * np.sin(2 * angles) / g plt.plot(np.degrees(angles), ranges, label=f'v\u2080 = {v0} m/s') plt.title('Projectile Range vs Angle of Projection') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.show()","title":"\ud83d\udcbb 4. Implementation (Python Script)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Here is a full solution to your Forced Damped Pendulum project \u2014 including theoretical derivation, dynamic analysis, real-world relevance, and a Python implementation with plots and exploration tools. Ready to copy into a Markdown or Jupyter notebook! \ud83c\udf00 Investigating the Dynamics of a Forced Damped Pendulum \ud83d\udcd8 1. Theoretical Foundation Equation of Motion The motion of a forced damped pendulum is described by the nonlinear second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] Where: - \\(\\theta(t)\\) : angular displacement - \\(\\gamma\\) : damping coefficient - \\(\\omega_0 = \\sqrt{g/L}\\) : natural angular frequency - \\(A\\) : amplitude of external forcing - \\(\\omega\\) : angular frequency of the driving force Small-Angle Approximation For small oscillations ( \\(\\theta \\ll 1\\) ), we use \\(\\sin\\theta \\approx \\theta\\) , simplifying the equation to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This is a driven damped harmonic oscillator , solvable analytically. General Solution (Small Angles) The solution consists of: - Transient (decays due to damping) - Steady-state (driven solution): \\[ \\theta(t) = \\theta_0 e^{-\\gamma t/2} \\cos(\\Omega t + \\phi) + B \\cos(\\omega t - \\delta) \\] Where: - \\(B = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (\\gamma \\omega)^2}}\\) - \\(\\delta = \\tan^{-1}\\left(\\frac{\\gamma \\omega}{\\omega_0^2 - \\omega^2}\\right)\\) Resonance Condition Occurs when driving frequency \\(\\omega \\approx \\omega_0\\) . - System absorbs maximum energy. - Amplitude \\(B\\) reaches a peak. - Damping reduces resonance sharpness. \ud83d\udd2c 2. Analysis of Dynamics Effect of Parameters Damping \\(\\gamma\\) : Low \\(\\gamma\\) : sustained oscillations. High \\(\\gamma\\) : motion dies out quickly. Driving Amplitude \\(A\\) : Small \\(A\\) : linear-like motion. Large \\(A\\) : complex, possibly chaotic behavior. Driving Frequency \\(\\omega\\) : Near resonance \u2192 large response. Far from resonance \u2192 low amplitude. Regular vs Chaotic Motion Regular : predictable, periodic or quasiperiodic. Chaotic : sensitive to initial conditions, irregular, non-repeating. Transition to chaos happens by increasing \\(A\\) or tuning \\(\\omega\\) . \ud83e\udde0 3. Real-World Applications Application Description \ud83c\udfd7\ufe0f Suspension Bridges External forcing (wind, traffic) causes oscillations \u26a1 RLC Circuits Analogous to pendulum with inductance/resistance \ud83d\udeb6 Biomechanics Human gait as forced pendulum \u2699\ufe0f Energy Harvesting Uses resonance for maximizing power \ud83d\udcbb 4. Python Implementation (Simulation) Below is a Python script using scipy and matplotlib . \ud83d\udd27 Required Libraries import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp \ud83d\udd01 Simulation Function # Parameters gamma = 0.1 # damping omega0 = 1.5 # natural frequency (sqrt(g/L)) A = 1.2 # driving amplitude omega = 2/3 # driving frequency def pendulum(t, y): theta, dtheta = y d2theta = -gamma * dtheta - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta, d2theta] \ud83e\uddea Solve the Equation # Initial conditions theta0 = 0.2 dtheta0 = 0.0 t_span = (0, 100) t_eval = np.linspace(*t_span, 5000) sol = solve_ivp(pendulum, t_span, [theta0, dtheta0], t_eval=t_eval) \ud83d\udcc8 Plot Time Evolution plt.figure(figsize=(10,4)) plt.plot(sol.t, sol.y[0], label='\u03b8(t)') plt.title('Forced Damped Pendulum - Angular Displacement Over Time') plt.xlabel('Time') plt.ylabel('Angle (rad)') plt.grid(True) plt.legend() plt.show() \ud83c\udf0c Phase Portrait plt.figure(figsize=(6,6)) plt.plot(sol.y[0], sol.y[1], lw=0.5) plt.title('Phase Portrait: \u03b8 vs d\u03b8/dt') plt.xlabel('\u03b8 (rad)') plt.ylabel('Angular velocity (rad/s)') plt.grid(True) plt.show() \ud83c\udf00 Poincar\u00e9 Section Sample the state every period of the driving force: T_drive = 2 * np.pi / omega sample_times = np.arange(0, 100, T_drive) theta_samples = [] omega_samples = [] for t_sample in sample_times: index = np.abs(sol.t - t_sample).argmin() theta_samples.append(sol.y[0][index]) omega_samples.append(sol.y[1][index]) plt.figure(figsize=(6,6)) plt.scatter(theta_samples, omega_samples, s=5) plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8 (rad)') plt.ylabel('d\u03b8/dt (rad/s)') plt.grid(True) plt.show() \ud83d\udcc9 5. Optional: Bifurcation Diagram Try plotting steady-state angle values for a range of amplitudes \\(A\\) : def get_bifurcation_data(A_values, omega=2/3): points = [] for A in A_values: def pend(t, y): theta, v = y return [v, -0.1 * v - 1.5**2 * np.sin(theta) + A * np.cos(omega * t)] sol = solve_ivp(pend, (0, 300), [0.1, 0], t_eval=np.linspace(200, 300, 1000)) T_drive = 2*np.pi / omega for t in np.arange(250, 300, T_drive): idx = np.abs(sol.t - t).argmin() points.append((A, sol.y[0][idx])) return points A_values = np.linspace(1.0, 1.5, 200) data = get_bifurcation_data(A_values) A_vals, theta_vals = zip(*data) plt.figure(figsize=(10,5)) plt.plot(A_vals, theta_vals, ',k') plt.title('Bifurcation Diagram: A vs \u03b8') plt.xlabel('Driving Amplitude A') plt.ylabel('\u03b8') plt.grid(True) plt.show() \ud83d\udea7 6. Limitations & Extensions Limitation Extension Assumes constant \\(\\gamma, A, \\omega\\) Add time-dependent forcing Only single pendulum Model coupled pendulums Idealized Add friction, noise, or nonlinear damping","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"Here is a full solution to your Forced Damped Pendulum project \u2014 including theoretical derivation, dynamic analysis, real-world relevance, and a Python implementation with plots and exploration tools. Ready to copy into a Markdown or Jupyter notebook!","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"\ud83c\udf00 Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"\ud83d\udcd8 1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#equation-of-motion","text":"The motion of a forced damped pendulum is described by the nonlinear second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] Where: - \\(\\theta(t)\\) : angular displacement - \\(\\gamma\\) : damping coefficient - \\(\\omega_0 = \\sqrt{g/L}\\) : natural angular frequency - \\(A\\) : amplitude of external forcing - \\(\\omega\\) : angular frequency of the driving force","title":"Equation of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations ( \\(\\theta \\ll 1\\) ), we use \\(\\sin\\theta \\approx \\theta\\) , simplifying the equation to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This is a driven damped harmonic oscillator , solvable analytically.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#general-solution-small-angles","text":"The solution consists of: - Transient (decays due to damping) - Steady-state (driven solution): \\[ \\theta(t) = \\theta_0 e^{-\\gamma t/2} \\cos(\\Omega t + \\phi) + B \\cos(\\omega t - \\delta) \\] Where: - \\(B = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (\\gamma \\omega)^2}}\\) - \\(\\delta = \\tan^{-1}\\left(\\frac{\\gamma \\omega}{\\omega_0^2 - \\omega^2}\\right)\\)","title":"General Solution (Small Angles)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"Occurs when driving frequency \\(\\omega \\approx \\omega_0\\) . - System absorbs maximum energy. - Amplitude \\(B\\) reaches a peak. - Damping reduces resonance sharpness.","title":"Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"\ud83d\udd2c 2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-parameters","text":"Damping \\(\\gamma\\) : Low \\(\\gamma\\) : sustained oscillations. High \\(\\gamma\\) : motion dies out quickly. Driving Amplitude \\(A\\) : Small \\(A\\) : linear-like motion. Large \\(A\\) : complex, possibly chaotic behavior. Driving Frequency \\(\\omega\\) : Near resonance \u2192 large response. Far from resonance \u2192 low amplitude.","title":"Effect of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#regular-vs-chaotic-motion","text":"Regular : predictable, periodic or quasiperiodic. Chaotic : sensitive to initial conditions, irregular, non-repeating. Transition to chaos happens by increasing \\(A\\) or tuning \\(\\omega\\) .","title":"Regular vs Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-real-world-applications","text":"Application Description \ud83c\udfd7\ufe0f Suspension Bridges External forcing (wind, traffic) causes oscillations \u26a1 RLC Circuits Analogous to pendulum with inductance/resistance \ud83d\udeb6 Biomechanics Human gait as forced pendulum \u2699\ufe0f Energy Harvesting Uses resonance for maximizing power","title":"\ud83e\udde0 3. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-python-implementation-simulation","text":"Below is a Python script using scipy and matplotlib .","title":"\ud83d\udcbb 4. Python Implementation (Simulation)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#required-libraries","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp","title":"\ud83d\udd27 Required Libraries"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#simulation-function","text":"# Parameters gamma = 0.1 # damping omega0 = 1.5 # natural frequency (sqrt(g/L)) A = 1.2 # driving amplitude omega = 2/3 # driving frequency def pendulum(t, y): theta, dtheta = y d2theta = -gamma * dtheta - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta, d2theta]","title":"\ud83d\udd01 Simulation Function"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#solve-the-equation","text":"# Initial conditions theta0 = 0.2 dtheta0 = 0.0 t_span = (0, 100) t_eval = np.linspace(*t_span, 5000) sol = solve_ivp(pendulum, t_span, [theta0, dtheta0], t_eval=t_eval)","title":"\ud83e\uddea Solve the Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#plot-time-evolution","text":"plt.figure(figsize=(10,4)) plt.plot(sol.t, sol.y[0], label='\u03b8(t)') plt.title('Forced Damped Pendulum - Angular Displacement Over Time') plt.xlabel('Time') plt.ylabel('Angle (rad)') plt.grid(True) plt.legend() plt.show()","title":"\ud83d\udcc8 Plot Time Evolution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#phase-portrait","text":"plt.figure(figsize=(6,6)) plt.plot(sol.y[0], sol.y[1], lw=0.5) plt.title('Phase Portrait: \u03b8 vs d\u03b8/dt') plt.xlabel('\u03b8 (rad)') plt.ylabel('Angular velocity (rad/s)') plt.grid(True) plt.show()","title":"\ud83c\udf0c Phase Portrait"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#poincare-section","text":"Sample the state every period of the driving force: T_drive = 2 * np.pi / omega sample_times = np.arange(0, 100, T_drive) theta_samples = [] omega_samples = [] for t_sample in sample_times: index = np.abs(sol.t - t_sample).argmin() theta_samples.append(sol.y[0][index]) omega_samples.append(sol.y[1][index]) plt.figure(figsize=(6,6)) plt.scatter(theta_samples, omega_samples, s=5) plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8 (rad)') plt.ylabel('d\u03b8/dt (rad/s)') plt.grid(True) plt.show()","title":"\ud83c\udf00 Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-optional-bifurcation-diagram","text":"Try plotting steady-state angle values for a range of amplitudes \\(A\\) : def get_bifurcation_data(A_values, omega=2/3): points = [] for A in A_values: def pend(t, y): theta, v = y return [v, -0.1 * v - 1.5**2 * np.sin(theta) + A * np.cos(omega * t)] sol = solve_ivp(pend, (0, 300), [0.1, 0], t_eval=np.linspace(200, 300, 1000)) T_drive = 2*np.pi / omega for t in np.arange(250, 300, T_drive): idx = np.abs(sol.t - t).argmin() points.append((A, sol.y[0][idx])) return points A_values = np.linspace(1.0, 1.5, 200) data = get_bifurcation_data(A_values) A_vals, theta_vals = zip(*data) plt.figure(figsize=(10,5)) plt.plot(A_vals, theta_vals, ',k') plt.title('Bifurcation Diagram: A vs \u03b8') plt.xlabel('Driving Amplitude A') plt.ylabel('\u03b8') plt.grid(True) plt.show()","title":"\ud83d\udcc9 5. Optional: Bifurcation Diagram"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-limitations-extensions","text":"Limitation Extension Assumes constant \\(\\gamma, A, \\omega\\) Add time-dependent forcing Only single pendulum Model coupled pendulums Idealized Add friction, noise, or nonlinear damping","title":"\ud83d\udea7 6. Limitations &amp; Extensions"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 \ud83d\udcd8 1. Theoretical Derivation We begin with Newton\u2019s Law of Gravitation and centripetal force for an object in circular orbit . \ud83e\udde0 Newton\u2019s Law of Universal Gravitation: \\[ F = \\frac{G M m}{r^2} \\] Where: - \\( F \\) : gravitational force - \\( G \\) : gravitational constant \\(6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2\\) - \\( M \\) : mass of central body (e.g., Earth or Sun) - \\( m \\) : mass of orbiting body - \\( r \\) : orbital radius \ud83c\udf00 Centripetal Force for Circular Orbit: \\[ F = \\frac{m v^2}{r} \\] Set the two forces equal: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancel \\( m \\) and solve for orbital velocity \\( v \\) : \\[ v^2 = \\frac{G M}{r} \\] Now recall: [ v = \\frac{2\\pi r}{T} ] Plug into velocity equation: \\[ \\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{G M}{r} \\] \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Multiply both sides by \\( T^2 r \\) : \\[ 4\\pi^2 r^3 = G M T^2 \\] Now solve for \\( T^2 \\) : \\[ \\boxed{T^2 = \\frac{4\\pi^2}{G M} \\cdot r^3} \\] This is Kepler\u2019s Third Law \u2014 the square of the orbital period is proportional to the cube of the orbital radius . \ud83c\udf0c 2. Implications for Astronomy Helps determine distances to planets (e.g. using their periods) Lets us calculate mass of celestial bodies by rearranging the formula Applies to moons , planets , satellites , even binary stars \ud83c\udf0d 3. Real-World Example: The Moon Let\u2019s apply Kepler\u2019s Law to the Moon orbiting Earth. Orbital radius \\( r = 384,400 \\) km = \\( 3.844 \\times 10^8 \\) m Mass of Earth \\( M = 5.972 \\times 10^{24} \\) kg We\u2019ll plug into: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] \ud83d\udcbb 4. Python Simulation & Plot Let\u2019s write Python code to: Simulate planets with different orbital radii Calculate orbital periods Plot \\( T^2 \\) vs \\( r^3 \\) to verify linear relationship import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth in kg # Orbital radii in meters (from 1e7 m to 5e8 m) radii = np.linspace(1e7, 5e8, 100) # Calculate orbital periods T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Kepler's law verification: T^2 vs r^3 T_squared = T**2 r_cubed = radii**3 # Plotting plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, label=\"Kepler's Third Law Verified\", color='purple') plt.xlabel(\"Orbital Radius\u00b3 (m\u00b3)\") plt.ylabel(\"Orbital Period\u00b2 (s\u00b2)\") plt.title(\"Kepler's Third Law: $T^2 \\\\propto r^3$\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() \ud83d\udcca Deliverables Recap \u2705 Derivation : Kepler\u2019s 3rd Law from Newtonian gravity \u2705 Applications : Planetary motion, satellites, moon orbits \u2705 Simulation : Period vs Radius in Python \u2705 Plot : Linear relationship between \\( T^2 \\) and \\( r^3 \\)","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-derivation","text":"We begin with Newton\u2019s Law of Gravitation and centripetal force for an object in circular orbit .","title":"\ud83d\udcd8 1. Theoretical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#newtons-law-of-universal-gravitation","text":"\\[ F = \\frac{G M m}{r^2} \\] Where: - \\( F \\) : gravitational force - \\( G \\) : gravitational constant \\(6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2\\) - \\( M \\) : mass of central body (e.g., Earth or Sun) - \\( m \\) : mass of orbiting body - \\( r \\) : orbital radius","title":"\ud83e\udde0 Newton\u2019s Law of Universal Gravitation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#centripetal-force-for-circular-orbit","text":"\\[ F = \\frac{m v^2}{r} \\] Set the two forces equal: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancel \\( m \\) and solve for orbital velocity \\( v \\) : \\[ v^2 = \\frac{G M}{r} \\] Now recall: [ v = \\frac{2\\pi r}{T} ] Plug into velocity equation: \\[ \\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{G M}{r} \\] \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Multiply both sides by \\( T^2 r \\) : \\[ 4\\pi^2 r^3 = G M T^2 \\] Now solve for \\( T^2 \\) : \\[ \\boxed{T^2 = \\frac{4\\pi^2}{G M} \\cdot r^3} \\] This is Kepler\u2019s Third Law \u2014 the square of the orbital period is proportional to the cube of the orbital radius .","title":"\ud83c\udf00 Centripetal Force for Circular Orbit:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"Helps determine distances to planets (e.g. using their periods) Lets us calculate mass of celestial bodies by rearranging the formula Applies to moons , planets , satellites , even binary stars","title":"\ud83c\udf0c 2. Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-example-the-moon","text":"Let\u2019s apply Kepler\u2019s Law to the Moon orbiting Earth. Orbital radius \\( r = 384,400 \\) km = \\( 3.844 \\times 10^8 \\) m Mass of Earth \\( M = 5.972 \\times 10^{24} \\) kg We\u2019ll plug into: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\]","title":"\ud83c\udf0d 3. Real-World Example: The Moon"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-python-simulation-plot","text":"Let\u2019s write Python code to: Simulate planets with different orbital radii Calculate orbital periods Plot \\( T^2 \\) vs \\( r^3 \\) to verify linear relationship import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth in kg # Orbital radii in meters (from 1e7 m to 5e8 m) radii = np.linspace(1e7, 5e8, 100) # Calculate orbital periods T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Kepler's law verification: T^2 vs r^3 T_squared = T**2 r_cubed = radii**3 # Plotting plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, label=\"Kepler's Third Law Verified\", color='purple') plt.xlabel(\"Orbital Radius\u00b3 (m\u00b3)\") plt.ylabel(\"Orbital Period\u00b2 (s\u00b2)\") plt.title(\"Kepler's Third Law: $T^2 \\\\propto r^3$\") plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"\ud83d\udcbb 4. Python Simulation &amp; Plot"},{"location":"1%20Physics/2%20Gravity/Problem_1/#deliverables-recap","text":"\u2705 Derivation : Kepler\u2019s 3rd Law from Newtonian gravity \u2705 Applications : Planetary motion, satellites, moon orbits \u2705 Simulation : Period vs Radius in Python \u2705 Plot : Linear relationship between \\( T^2 \\) and \\( r^3 \\)","title":"\ud83d\udcca Deliverables Recap"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 \ud83d\ude80 1. Defining the Cosmic Velocities These velocities are thresholds for different types of motion under gravity. First Cosmic Velocity (Orbital Velocity) Definition : Minimum speed needed to enter low circular orbit around a planet (just above the surface). Meaning : Object doesn't fall back \u2014 it falls around the planet. \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Second Cosmic Velocity (Escape Velocity) Definition : Minimum speed to completely escape the gravity of a planet. Meaning : Object never returns unless acted on. \\[ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{r}} \\] Third Cosmic Velocity (Interstellar Escape) Definition : Minimum speed to escape the Solar System , from Earth orbit. Meaning : Object escapes Sun\u2019s gravity starting from a planet like Earth. \\[ v_3 = \\sqrt{v_{\\text{esc,Sun}}^2 + v_{\\text{orb,Earth}}^2} \\] Where: - \\( v_{\\text{esc,Sun}} \\) : escape velocity from the Sun at Earth\u2019s orbit - \\( v_{\\text{orb,Earth}} \\) : Earth\u2019s orbital speed around the Sun \ud83e\udde0 2. Derivation of Escape Velocity From energy conservation: \\[ \\text{Kinetic energy} = \\text{Gravitational potential energy} \\] \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\Rightarrow v = \\sqrt{\\frac{2GM}{r}} \\] Where: - \\( G \\) : gravitational constant = \\(6.67430 \\times 10^{-11} \\) - \\( M \\) : mass of the planet/star - \\( r \\) : distance from center of mass \ud83c\udf0d 3. Examples for Earth, Mars, Jupiter Let\u2019s compute the 3 cosmic velocities for Earth, Mars, and Jupiter: Planet Mass (kg) Radius (m) Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) Mars \\(6.417 \\times 10^{23}\\) \\(3.390 \\times 10^6\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.991 \\times 10^7\\) \ud83d\udcbb 4. Python Simulation and Visualization Here\u2019s Python code to calculate and visualize cosmic velocities: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 # Planet data: name, mass (kg), radius (m) planets = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.390e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.991e7} } # Calculate velocities results = {} for planet, data in planets.items(): M = data[\"mass\"] r = data[\"radius\"] v1 = np.sqrt(G * M / r) # First cosmic (orbital) v2 = np.sqrt(2 * G * M / r) # Second cosmic (escape) results[planet] = { \"v1_kms\": v1 / 1000, \"v2_kms\": v2 / 1000 } # Plotting labels = list(results.keys()) v1_vals = [results[p][\"v1_kms\"] for p in labels] v2_vals = [results[p][\"v2_kms\"] for p in labels] x = np.arange(len(labels)) width = 0.35 plt.figure(figsize=(10,6)) plt.bar(x - width/2, v1_vals, width, label=\"1st Cosmic Velocity (Orbital)\") plt.bar(x + width/2, v2_vals, width, label=\"2nd Cosmic Velocity (Escape)\") plt.xticks(x, labels) plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities for Planets\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() \ud83d\udcca Deliverables Recap \u2705 Markdown or Notebook : With theory + code \u2705 Equations : For each cosmic velocity \u2705 Calculations : For Earth, Mars, and Jupiter \u2705 Graph : Comparing velocities across planets \u2705 Extension : Third cosmic velocity (leaving the Solar System)","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-defining-the-cosmic-velocities","text":"These velocities are thresholds for different types of motion under gravity.","title":"\ud83d\ude80 1. Defining the Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"Definition : Minimum speed needed to enter low circular orbit around a planet (just above the surface). Meaning : Object doesn't fall back \u2014 it falls around the planet. \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\]","title":"First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"Definition : Minimum speed to completely escape the gravity of a planet. Meaning : Object never returns unless acted on. \\[ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{r}} \\]","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-interstellar-escape","text":"Definition : Minimum speed to escape the Solar System , from Earth orbit. Meaning : Object escapes Sun\u2019s gravity starting from a planet like Earth. \\[ v_3 = \\sqrt{v_{\\text{esc,Sun}}^2 + v_{\\text{orb,Earth}}^2} \\] Where: - \\( v_{\\text{esc,Sun}} \\) : escape velocity from the Sun at Earth\u2019s orbit - \\( v_{\\text{orb,Earth}} \\) : Earth\u2019s orbital speed around the Sun","title":"Third Cosmic Velocity (Interstellar Escape)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-derivation-of-escape-velocity","text":"From energy conservation: \\[ \\text{Kinetic energy} = \\text{Gravitational potential energy} \\] \\[ \\frac{1}{2}mv^2 = \\frac{GMm}{r} \\Rightarrow v = \\sqrt{\\frac{2GM}{r}} \\] Where: - \\( G \\) : gravitational constant = \\(6.67430 \\times 10^{-11} \\) - \\( M \\) : mass of the planet/star - \\( r \\) : distance from center of mass","title":"\ud83e\udde0 2. Derivation of Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-examples-for-earth-mars-jupiter","text":"Let\u2019s compute the 3 cosmic velocities for Earth, Mars, and Jupiter: Planet Mass (kg) Radius (m) Earth \\(5.972 \\times 10^{24}\\) \\(6.371 \\times 10^6\\) Mars \\(6.417 \\times 10^{23}\\) \\(3.390 \\times 10^6\\) Jupiter \\(1.898 \\times 10^{27}\\) \\(6.991 \\times 10^7\\)","title":"\ud83c\udf0d 3. Examples for Earth, Mars, Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-python-simulation-and-visualization","text":"Here\u2019s Python code to calculate and visualize cosmic velocities: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 # Planet data: name, mass (kg), radius (m) planets = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.390e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.991e7} } # Calculate velocities results = {} for planet, data in planets.items(): M = data[\"mass\"] r = data[\"radius\"] v1 = np.sqrt(G * M / r) # First cosmic (orbital) v2 = np.sqrt(2 * G * M / r) # Second cosmic (escape) results[planet] = { \"v1_kms\": v1 / 1000, \"v2_kms\": v2 / 1000 } # Plotting labels = list(results.keys()) v1_vals = [results[p][\"v1_kms\"] for p in labels] v2_vals = [results[p][\"v2_kms\"] for p in labels] x = np.arange(len(labels)) width = 0.35 plt.figure(figsize=(10,6)) plt.bar(x - width/2, v1_vals, width, label=\"1st Cosmic Velocity (Orbital)\") plt.bar(x + width/2, v2_vals, width, label=\"2nd Cosmic Velocity (Escape)\") plt.xticks(x, labels) plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities for Planets\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"\ud83d\udcbb 4. Python Simulation and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#deliverables-recap","text":"\u2705 Markdown or Notebook : With theory + code \u2705 Equations : For each cosmic velocity \u2705 Calculations : For Earth, Mars, and Jupiter \u2705 Graph : Comparing velocities across planets \u2705 Extension : Third cosmic velocity (leaving the Solar System)","title":"\ud83d\udcca Deliverables Recap"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 \ud83c\udf0d 1. Theoretical Overview: Payload Trajectories Near Earth Types of Trajectories: When a payload is released from a moving spacecraft near Earth, its trajectory depends on its initial velocity vector relative to Earth. It will follow one of these conic sections: Type Speed Relative to Escape Velocity Orbit Shape Circular Exactly orbital speed Circle Elliptical Less than escape speed Ellipse Parabolic Exactly escape speed Parabola Hyperbolic Greater than escape speed Hyperbola Suborbital Too low to complete an orbit Falls to Earth \u2699\ufe0f 2. Governing Equations Newton\u2019s Law of Gravitation: \\[ \\vec{F} = - \\frac{G M m}{r^2} \\hat{r} \\] This leads to an acceleration toward Earth\u2019s center: [ \\vec{a} = -\\frac{G M}{r^2} \\hat{r} ] Where: - \\( G = 6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) - \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) - \\( r \\) : distance from Earth's center - \\( \\hat{r} \\) : unit vector pointing from object to Earth's center We\u2019ll numerically solve: \\( \\frac{d\\vec{v}}{dt} = \\vec{a} \\) \\( \\frac{d\\vec{r}}{dt} = \\vec{v} \\) Using the Euler or RK4 method. \ud83d\udcca 3. Python Simulation: Visualizing Payload Trajectories We'll use this to simulate the motion of a payload from different speeds at a set altitude. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Mass of Earth R_earth = 6.371e6 # Radius of Earth (m) # Simulation parameters dt = 1 # time step (s) total_time = 10000 # total simulation time (s) steps = int(total_time / dt) def simulate_trajectory(v0, angle_deg, altitude): # Initial conditions r0 = R_earth + altitude theta = np.radians(angle_deg) pos = np.array([r0, 0]) vel = v0 * np.array([0, 1]) # Launch tangentially positions = [] for _ in range(steps): r = np.linalg.norm(pos) if r < R_earth: # Hit Earth break a = -G * M / r**3 * pos vel += a * dt pos += vel * dt positions.append(pos.copy()) return np.array(positions) # Simulate various speeds at 300 km altitude altitude = 300e3 v_circular = np.sqrt(G * M / (R_earth + altitude)) v_escape = np.sqrt(2) * v_circular velocities = [0.8 * v_circular, v_circular, 1.1 * v_circular, v_escape] labels = ['Suborbital', 'Circular', 'Elliptical', 'Escape'] # Plotting plt.figure(figsize=(8, 8)) for v, label in zip(velocities, labels): traj = simulate_trajectory(v, 90, altitude) plt.plot(traj[:,0]/1e6, traj[:,1]/1e6, label=label) # Draw Earth earth = plt.Circle((0, 0), R_earth/1e6, color='skyblue', alpha=0.5) plt.gca().add_patch(earth) plt.xlabel(\"x position (Mm)\") plt.ylabel(\"y position (Mm)\") plt.title(\"Payload Trajectories from Low Earth Orbit\") plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show() \ud83d\udcd8 4. Key Observations Speeds < orbital velocity \u2192 payload returns to Earth (suborbital) Speed = orbital \u2192 stable circular orbit Speed > orbital, < escape \u2192 elliptical orbit Speed = escape \u2192 parabolic escape Speed > escape \u2192 hyperbolic escape \ud83d\udcbc 5. Applications Use Case Trajectory Type Launching Satellites Circular/Elliptical Space Station Supply Elliptical/Rendezvous Moon Mission / Interplanetary Escape / Hyperbolic Returning to Earth Suborbital/Reentry \ud83d\udcc2 Deliverables Recap \u2705 Markdown/Notebook : With equations, explanations, and Python \u2705 Numerical Simulation : Integrates motion under gravity \u2705 Trajectories : Suborbital, circular, elliptical, escape \u2705 Real-world Link : Relates directly to space missions","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-theoretical-overview-payload-trajectories-near-earth","text":"","title":"\ud83c\udf0d 1. Theoretical Overview: Payload Trajectories Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"When a payload is released from a moving spacecraft near Earth, its trajectory depends on its initial velocity vector relative to Earth. It will follow one of these conic sections: Type Speed Relative to Escape Velocity Orbit Shape Circular Exactly orbital speed Circle Elliptical Less than escape speed Ellipse Parabolic Exactly escape speed Parabola Hyperbolic Greater than escape speed Hyperbola Suborbital Too low to complete an orbit Falls to Earth","title":"Types of Trajectories:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-governing-equations","text":"","title":"\u2699\ufe0f 2. Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-gravitation","text":"\\[ \\vec{F} = - \\frac{G M m}{r^2} \\hat{r} \\] This leads to an acceleration toward Earth\u2019s center: [ \\vec{a} = -\\frac{G M}{r^2} \\hat{r} ] Where: - \\( G = 6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) - \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) - \\( r \\) : distance from Earth's center - \\( \\hat{r} \\) : unit vector pointing from object to Earth's center","title":"Newton\u2019s Law of Gravitation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#well-numerically-solve","text":"\\( \\frac{d\\vec{v}}{dt} = \\vec{a} \\) \\( \\frac{d\\vec{r}}{dt} = \\vec{v} \\) Using the Euler or RK4 method.","title":"We\u2019ll numerically solve:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-python-simulation-visualizing-payload-trajectories","text":"We'll use this to simulate the motion of a payload from different speeds at a set altitude. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Mass of Earth R_earth = 6.371e6 # Radius of Earth (m) # Simulation parameters dt = 1 # time step (s) total_time = 10000 # total simulation time (s) steps = int(total_time / dt) def simulate_trajectory(v0, angle_deg, altitude): # Initial conditions r0 = R_earth + altitude theta = np.radians(angle_deg) pos = np.array([r0, 0]) vel = v0 * np.array([0, 1]) # Launch tangentially positions = [] for _ in range(steps): r = np.linalg.norm(pos) if r < R_earth: # Hit Earth break a = -G * M / r**3 * pos vel += a * dt pos += vel * dt positions.append(pos.copy()) return np.array(positions) # Simulate various speeds at 300 km altitude altitude = 300e3 v_circular = np.sqrt(G * M / (R_earth + altitude)) v_escape = np.sqrt(2) * v_circular velocities = [0.8 * v_circular, v_circular, 1.1 * v_circular, v_escape] labels = ['Suborbital', 'Circular', 'Elliptical', 'Escape'] # Plotting plt.figure(figsize=(8, 8)) for v, label in zip(velocities, labels): traj = simulate_trajectory(v, 90, altitude) plt.plot(traj[:,0]/1e6, traj[:,1]/1e6, label=label) # Draw Earth earth = plt.Circle((0, 0), R_earth/1e6, color='skyblue', alpha=0.5) plt.gca().add_patch(earth) plt.xlabel(\"x position (Mm)\") plt.ylabel(\"y position (Mm)\") plt.title(\"Payload Trajectories from Low Earth Orbit\") plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"\ud83d\udcca 3. Python Simulation: Visualizing Payload Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-key-observations","text":"Speeds < orbital velocity \u2192 payload returns to Earth (suborbital) Speed = orbital \u2192 stable circular orbit Speed > orbital, < escape \u2192 elliptical orbit Speed = escape \u2192 parabolic escape Speed > escape \u2192 hyperbolic escape","title":"\ud83d\udcd8 4. Key Observations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-applications","text":"Use Case Trajectory Type Launching Satellites Circular/Elliptical Space Station Supply Elliptical/Rendezvous Moon Mission / Interplanetary Escape / Hyperbolic Returning to Earth Suborbital/Reentry","title":"\ud83d\udcbc 5. Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#deliverables-recap","text":"\u2705 Markdown/Notebook : With equations, explanations, and Python \u2705 Numerical Simulation : Integrates motion under gravity \u2705 Trajectories : Suborbital, circular, elliptical, escape \u2705 Real-world Link : Relates directly to space missions","title":"\ud83d\udcc2 Deliverables Recap"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}